<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>9pfsPkg: Network Boot from Bell Labs - retrage.github.io</title>
<meta name=theme-color><meta name=description content="I developed a Plan 9 file system (9P) client for UEFI to enable network booting from a commodity 9P server. By leveraging the simplicity and flexibility of 9P, the UEFI can do network boot from cloud storage without any effort. This blog post gives you a brief overview of 9pfsPkg.
The source code, introduction slides, and presentation video are available at:

https://github.com/yabits/9pfsPkg
https://speakerdeck.com/retrage/network-boot-from-bell-labs
https://youtu.be/3PX19nWrygQ

What is Network Boot?
Network boot is a boot method which loading boot images over the network. To make this possible, the BIOS has its network stack.
There are two methods for network booting: PXE Boot and HTTP Boot."><meta name=author content="Akira Moroo"><link rel="preload stylesheet" as=style href=https://retrage.github.io/main.min.css><link rel=preload as=image href=https://retrage.github.io/theme.png><link rel=preload as=image href=https://github.com/retrage.png><link rel=preload as=image href=https://retrage.github.io/twitter.svg><link rel=preload as=image href=https://retrage.github.io/github.svg><link rel=preload as=image href=https://retrage.github.io/rss.svg><script defer src=https://retrage.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://retrage.github.io/favicon.ico><link rel=apple-touch-icon href=https://retrage.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.134.2"><meta itemprop=name content="9pfsPkg: Network Boot from Bell Labs"><meta itemprop=description content="I developed a Plan 9 file system (9P) client for UEFI to enable network booting from a commodity 9P server. By leveraging the simplicity and flexibility of 9P, the UEFI can do network boot from cloud storage without any effort. This blog post gives you a brief overview of 9pfsPkg.
The source code, introduction slides, and presentation video are available at:
https://github.com/yabits/9pfsPkg https://speakerdeck.com/retrage/network-boot-from-bell-labs https://youtu.be/3PX19nWrygQ What is Network Boot? Network boot is a boot method which loading boot images over the network. To make this possible, the BIOS has its network stack. There are two methods for network booting: PXE Boot and HTTP Boot."><meta itemprop=datePublished content="2020-08-01T16:15:51+00:00"><meta itemprop=dateModified content="2020-08-01T16:15:51+00:00"><meta itemprop=wordCount content="1553"><meta property="og:url" content="https://retrage.github.io/2020/08/01/9pfspkg-en.html/"><meta property="og:site_name" content="retrage.github.io"><meta property="og:title" content="9pfsPkg: Network Boot from Bell Labs"><meta property="og:description" content="I developed a Plan 9 file system (9P) client for UEFI to enable network booting from a commodity 9P server. By leveraging the simplicity and flexibility of 9P, the UEFI can do network boot from cloud storage without any effort. This blog post gives you a brief overview of 9pfsPkg.
The source code, introduction slides, and presentation video are available at:
https://github.com/yabits/9pfsPkg https://speakerdeck.com/retrage/network-boot-from-bell-labs https://youtu.be/3PX19nWrygQ What is Network Boot? Network boot is a boot method which loading boot images over the network. To make this possible, the BIOS has its network stack. There are two methods for network booting: PXE Boot and HTTP Boot."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-08-01T16:15:51+00:00"><meta property="article:modified_time" content="2020-08-01T16:15:51+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="9pfsPkg: Network Boot from Bell Labs"><meta name=twitter:description content="I developed a Plan 9 file system (9P) client for UEFI to enable network booting from a commodity 9P server. By leveraging the simplicity and flexibility of 9P, the UEFI can do network boot from cloud storage without any effort. This blog post gives you a brief overview of 9pfsPkg.
The source code, introduction slides, and presentation video are available at:
https://github.com/yabits/9pfsPkg https://speakerdeck.com/retrage/network-boot-from-bell-labs https://youtu.be/3PX19nWrygQ What is Network Boot? Network boot is a boot method which loading boot images over the network. To make this possible, the BIOS has its network stack. There are two methods for network booting: PXE Boot and HTTP Boot."><link rel=canonical href=https://retrage.github.io/2020/08/01/9pfspkg-en.html/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://retrage.github.io/>retrage.github.io</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>Posts</a></nav><nav class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/retrage target=_blank rel=me>twitter
</a><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/retrage target=_blank rel=me>github
</a><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://retrage.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">9pfsPkg: Network Boot from Bell Labs</h1><div class="text-xs antialiased opacity-60"><time>Aug 1, 2020</time></div></header><section><p>I developed a Plan 9 file system (9P) client for UEFI to enable network booting from a commodity 9P server. By leveraging the simplicity and flexibility of 9P, the UEFI can do network boot from cloud storage without any effort. This blog post gives you a brief overview of 9pfsPkg.</p><p>The source code, introduction slides, and presentation video are available at:</p><ul><li><a href=https://github.com/yabits/9pfsPkg>https://github.com/yabits/9pfsPkg</a></li><li><a href=https://speakerdeck.com/retrage/network-boot-from-bell-labs>https://speakerdeck.com/retrage/network-boot-from-bell-labs</a></li><li><a href=https://youtu.be/3PX19nWrygQ>https://youtu.be/3PX19nWrygQ</a></li></ul><h2 id=what-is-network-boot>What is Network Boot?</h2><p>Network boot is a boot method which loading boot images over the network. To make this possible, the BIOS has its network stack.
There are two methods for network booting: PXE Boot and HTTP Boot.</p><p>PXE (Pre-eXecution Environment) Boot is the most widely used method as it exists from the Legacy BIOS era. It is standardized and implemented as not only proprietary but also open source. PXE boot uses TFTP to transfer files. This protocol is not popular, so it requires a dedicated TFTP server.</p><p>HTTP Boot uses HTTP for transferring images. It has been standardized from UEFI 2.5 in 2015[0]. It supports modern features like DNS and TLS. Since it uses HTTP, we can use commodity HTTP servers (e.g. Apache HTTP Server, Nginx).</p><p>Below is the interface of the HTTP protocol.</p><p><img src=/img/9pfspkg-efi-http-protocol.png alt="EFI HTTP Protocol"></p><p><code>Configure()</code> sets the configuration, <code>Request()</code> sends a request, and <code>Response()</code> receives a response. By using these functions, we can implement HTTP Boot bootloader like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>EFI_STATUS <span style=color:#a6e22e>HttpBootLoader</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Send request
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Status <span style=color:#f92672>=</span> Http<span style=color:#f92672>-&gt;</span>Request (Http, TxToken);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Recieve response
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Status <span style=color:#f92672>=</span> Http<span style=color:#f92672>-&gt;</span>Response (Http, RxToken);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Start loaded image
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Status <span style=color:#f92672>=</span> gBS<span style=color:#f92672>-&gt;</span>StartImage (ImageHandle, NULL, NULL);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Status;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This example shows how it is easy to boot with HTTP on UEFI.</p><h2 id=uefi-is-extensible>UEFI is Extensible</h2><p>UEFI is an abbreviation of the Unified Extensible Firmware Interface. As it includes the word &ldquo;Extensible,&rdquo; it has a modular design. The modules are called &ldquo;Protocol&rdquo; and UEFI has features that load external protocols in its core. By calling <code>EFI_BOOT_SERVICES.InstallProtocolInterface()</code> with passing a loaded protocol to <code>Interface</code> argument, it installs an external protocol.</p><p><img src=/img/9pfspkg-efi-install-protocol-interface.png alt=EFI_BOOT_SERVICES.InstallProtocolInterface()></p><p>As an example of a UEFI protocol, I introduce the Simple File System Protocol. This protocol provides a file system independent file operation interfaces. Here is a figure of the interfaces.</p><p><img src=/img/9pfspkg-efi-simple-file-system-protocol.png alt="EFI Simple File System Protocol"></p><p><code>OpenVolume()</code> in Simple File System Protocol opens a volume and returns File Protocol <code>Root</code> that represents the root directory. File Protocol provides file operation functions like <code>Open()</code>, <code>Read()</code>, <code>Write()</code>.</p><p>However, even it has abstract interfaces, UEFI supports the FAT file system only by default. There are some third-party non-FAT file system drivers. Here is an example of the use of such a file system driver: UEFI Rootkits. A rootkit is malware that targets kernels or firmware. Once infected, it installs other rootkits and/or agents. Hacking Team&rsquo;s rkloader[2] and LoJax[3] are such UEFI rootkits. They have NTFS UEFI drivers to embed kernel rootkits to the target Windows system. This driver is a port of NTFS-3G, an open-source NTFS implementation, and has Simple File System Protocol as an interface. The following snippet from the rkloader shows how Simple File System Protocol makes embedding an agent easy.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>EFI_STATUS
</span></span><span style=display:flex><span>EFIAPI
</span></span><span style=display:flex><span><span style=color:#a6e22e>InstallAgent</span>(
</span></span><span style=display:flex><span>  IN EFI_FILE_HANDLE CurDir,
</span></span><span style=display:flex><span>  IN CHAR16	<span style=color:#f92672>*</span>  FileNameUser
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Open FileNameScout as FileHandle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Status <span style=color:#f92672>=</span> CurDir<span style=color:#f92672>-&gt;</span>Open (CurDir, <span style=color:#f92672>&amp;</span>FileHandle, FileNameScout, EFI_FILE_MODE_READ<span style=color:#f92672>|</span>EFI_FILE_MODE_WRITE<span style=color:#f92672>|</span>EFI_FILE_MODE_CREATE, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Write pSectiondata to FileHandle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Status <span style=color:#f92672>=</span> FileHandle<span style=color:#f92672>-&gt;</span>Write(FileHandle,<span style=color:#f92672>&amp;</span>VirtualSize,(UINT8<span style=color:#f92672>*</span>)(pSectiondata));
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Close FileHandle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Status <span style=color:#f92672>=</span> FileHandle<span style=color:#f92672>-&gt;</span>Close(FileHandle);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> EFI_SUCCESS;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First of all, open a file by <code>Open()</code>, deploy the agent by <code>Write()</code>, and close the file with <code>Close()</code>. As you can see, it is simple and does not have any trick.</p><h2 id=plan-9-file-protocol>Plan 9 File Protocol</h2><p>Now, let&rsquo;s think about network boot. I pointed out that the current network boots are network-aware and less flexibility. Thus, we want a network transparent file system and protocol for network boot while maintaining the feasibility of the file system.</p><p>Here is the answer: Plan 9 File Protocol (9P)[8]</p><p>Plan 9 from Bell Labs (Plan 9)[7] is a Unix successor OS developed by the original Unix developer in Bell Labs. &ldquo;Everything is a file.&rdquo;, which is a well known Unix philosophy, is a core design decision on Plan 9. P9 is a protocol developed by Plan 9 developers to deal with remote files in the same manner as local files. Below is a flow of loading a file with 9P.</p><p><img src=/img/9pfspkg-9p-flow.png alt="9P Flow"></p><p>The client negotiates by <code>version</code> and connects with <code>attach</code> to get a file descriptor of the root directory. <code>walk</code> searches to the target file, <code>open</code> it, and <code>read</code> it. As you can see, 9P is a protocol that file operations and messages correspond to one-by-one.</p><p>9P is popular in the fields of not related to Plan 9 due to clarity and simplicity. For instance, the Linux kernel has a 9P client file system called v9fs[4]. VirtIO has a virtio-9p 9P server to share the host file system with the guests[5].</p><p>Recently, Microsoft has released Windows 10 update, and Windows Subsystem for Linux 2 (WSL2) is now officially supported. It runs a guest Linux on the Hyper-V VM in contrast to WSL1. Because VM disk image is a monolithic file, it is hard to access inside files with the same manner of host file access. To solve this issue, WSL2 uses 9P to access guest files from the host. The host Windows has 9P client to access the guest Linux files. The guest has a 9P server to process requests from the host to share the files[6].</p><h2 id=9pfspkg>9pfsPkg</h2><p>As I described in the previous section, 9P is still widely used nowadays. I implemented a 9P client file system for UEFI: 9pfsPkg.</p><ul><li><a href=https://github.com/yabits/9pfsPkg>https://github.com/yabits/9pfsPkg</a></li></ul><p>9pfsPkg is a 9P client file system UEFI driver with a Simple File System Protocol interface. Because 9P is a network transparent file system, we can use existing non-network-aware tools (e.g. UEFI Shell) for file operations via networks without any modification by using 9pfsPkg. Another advantage of the file system is that it does not require dedicated servers (like TFTP in PXE Boot).</p><h2 id=9p-boot>9P Boot</h2><p>Let&rsquo;s take a look at a boot by 9P (9P Boot). The below shows the overview.</p><p><img src=/img/9pfspkg-9p-boot-overview.png alt="9P Boot Overview"></p><p>First of all, the 9P service runs on the server with an exported directory (e.g. <code>/tmp/9</code>). Next, the client loads the 9pfsPkg UEFI driver to create a new volume. The driver processes operations to the file system volume and communicates with the server via the UEFI network stack to handle the file operations.</p><p>The below video clip shows what it looks:</p><ul><li><a href="https://twitter.com/retrage/status/1262396289901309955?s=20">https://twitter.com/retrage/status/1262396289901309955?s=20</a></li></ul><p>When the UEFI startups, we can see the local file system <code>FS0:</code> only.</p><pre tabindex=0><code>Mapping table
      FS0: Alias(s):HD0a65535a1:;BLK1:
          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)
     BLK0: Alias(s):
          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)
     BLK2: Alias(s):
          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)
</code></pre><p>Load 9pfsPkg UEFI driver by <code>load 9pfs.efi</code>.</p><pre tabindex=0><code>FS0:\&gt; load 9pfs.efi
Image &#39;FS0:\9pfs.efi&#39; loaded at 7E2E7000 - Success
</code></pre><p>The new file system <code>FS1:</code> has appeared.</p><pre tabindex=0><code>Mapping table
      FS0: Alias(s):HD0a65535a1:;BLK1:                                          
          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)
      FS1: Alias(s):F1:
          PciRoot(0x0)/Pci(0x2,0x0)/MAC(525400123456,0x1)
     BLK0: Alias(s):
          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)
     BLK2: Alias(s):
          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)
</code></pre><p>In contrast to local <code>FS0:</code>, the device path of remote <code>FS1:</code> is <code>PciRoot(0x0)/Pci(0x2,0x0)/MAC(525400123456,0x1)</code>. It represents that the volume is on the remote server.</p><p>By executing <code>fs1:</code> and <code>grubx64.efi</code>, it boots the bootloader GRUB.</p><pre tabindex=0><code>FS0:\&gt; fs1:
FS1:\&gt; grubx64.efi
                             GNU GRUB  version 2.02

   Minimal BASH-like line editing is supported. For the first word, TAB
   lists possible command completions. Anywhere else TAB lists possible
   device or file completions.


grub&gt;
</code></pre><p>At this point, UEFI Shell and GRUB deal with the remote files in the same manner as local files. There is no network boot specific process.</p><h2 id=proxy-boot>Proxy Boot</h2><p>9P Boot enables non-network-aware network boot. To take more advantages of the 9P, I propose Proxy Boot as an application of 9P Boot. It can boot from other servers via the direct server as a proxy. By using Proxy Boot, UEFI can boot from cloud storage without any effort. Following is the overview of Proxy Boot.</p><p><img src=/img/9pfspkg-proxy-boot-overview.png alt="Proxy Boot Overview"></p><p>I used Google Cloud Storage (GCS) for the network boot. The storage bucket has boot images. The server mounts the bucket as a file system using gcsfuse[9]. The 9P server uses the gcsfuse&rsquo;s mount point (e.g. /mnt/gcs) as an exported directory. The client mounts the volume in the same manner as 9P Boot. The client UEFI can treat the cloud storage files as if local files.</p><p>The below is the demo:</p><ul><li><a href="https://twitter.com/retrage/status/1267762465703485445?s=20">https://twitter.com/retrage/status/1267762465703485445?s=20</a></li></ul><p>Create a GCS bucket and upload boot images. I used BitVisor (thin-hypervisor) as a practical boot image. <code>loadvmm.efi</code> is the loader, and <code>bitvisor.elf</code> is the actual BitVisor image. They are default build and no modification for the network boot.</p><p><img src=/img/9pfspkg-gcs-bucket.png alt="GCS Bucket"></p><p>Next, mount the bucket on the server using gcsfuse at <code>/mnt/gcs</code> mount point.</p><pre tabindex=0><code>$ sudo -E gcsfuse proxy-boot /mnt/gcs
 Using mount point: /mnt/gcs
Opening GCS connection...
Opening bucket...
Mounting file system...
File system has been successfully mounted.
</code></pre><p>On the client, load the driver with <code>load 9pfs.efi</code>, move to <code>fs1:</code>, and call <code>loadvmm.efi</code> to boot BitVisor.</p><pre tabindex=0><code>Shell&gt; fs0:
FS0:\&gt; load 9pfs.efi
FS0:\&gt; map -u
FS0:\&gt; fs1:
FS1:\&gt; loadvmm.efi
Starting BitVisor...
Copyright (c) 2007, 2008 University of Tsukuba
All rights reserved.
</code></pre><p>Once again, the UEFI Shell and <code>loadvmm.efi</code> operates the cloud storage files as if local files, and there is no cloud-specific process.</p><h2 id=conclusion>Conclusion</h2><p>In this blog post, I pointed out that the existing network boots are network-aware and less flexible. The 9P client file system for UEFI (9pfsPkg) enables network transparent network boot (9P Boot). As an application of the 9pfsPkg, I proposed a network boot from cloud storage via the server (Proxy Boot) without any effort.</p><h2 id=references>References</h2><ul><li>[0] <a href=https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_A_Feb14.pdf>https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_A_Feb14.pdf</a></li><li>[1] <a href=https://tnishinaga.hatenablog.com/entry/2017/12/22/221956>https://tnishinaga.hatenablog.com/entry/2017/12/22/221956</a></li><li>[2] <a href=https://github.com/hackedteam/vector-edk>https://github.com/hackedteam/vector-edk</a></li><li>[3] <a href=https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf>https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf</a></li><li>[4] <a href=https://www.kernel.org/doc/Documentation/filesystems/9p.txt>https://www.kernel.org/doc/Documentation/filesystems/9p.txt</a></li><li>[5] <a href=https://www.linux-kvm.org/page/9p_virtio>https://www.linux-kvm.org/page/9p_virtio</a></li><li>[6] <a href="https://youtu.be/63wVlI9B3Ac?t=481">https://youtu.be/63wVlI9B3Ac?t=481</a></li><li>[7] <a href=https://9p.io/plan9/>https://9p.io/plan9/</a></li><li>[8] <a href=http://man.cat-v.org/plan_9/5/>http://man.cat-v.org/plan_9/5/</a></li><li>[9] <a href=https://github.com/GoogleCloudPlatform/gcsfuse>https://github.com/GoogleCloudPlatform/gcsfuse</a></li></ul></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://retrage.github.io/2021/09/18/apfs-efi-jumpstart.html/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Apple File Systemの下にはEFI driverが埋まっている</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://retrage.github.io/2020/06/15/9pfspkg.html/><span>UEFI向け9P File Systemを作ってクラウドからネットワークブートできるようにした</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://retrage.github.io/>retrage.github.io</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>