<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>retrage.github.io</title><link>https://retrage.github.io/</link><description>Recent content on retrage.github.io</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 31 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://retrage.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>今年の振り返り</title><link>https://retrage.github.io/2023/12/31/2023-review.html/</link><pubDate>Sun, 31 Dec 2023 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2023/12/31/2023-review.html/</guid><description>今年もそろそろ終わりそうなので、何やったかを振り返ってみる。 aarch64 Support for Rust Hypervisor Firmware ~1月 Rust Hypervisor Firmwareはいままでx86_64でしか動かなかったが</description></item><item><title>OSはどうやってP-coreとE-coreを使い分けているのか</title><link>https://retrage.github.io/2023/08/20/intel-hfi.html/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2023/08/20/intel-hfi.html/</guid><description>Alder Lake以降のIntel CPUでは、P-coreとE-coreの2種類のコアが搭載されている。 P-coreは性能重視、E-coreは省電力</description></item><item><title>VisionFive 2をJTAGデバッグ</title><link>https://retrage.github.io/2023/03/25/visionfive2-jtag-debugging.html/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2023/03/25/visionfive2-jtag-debugging.html/</guid><description>VisionFive 2 (以下、VF2) はStarFive Technologyが開発したSBCである。名前からわかるように、RISC-VのSoCを搭載している。</description></item><item><title>2022年にやったこと</title><link>https://retrage.github.io/2022/12/31/2022-review.html/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2022/12/31/2022-review.html/</guid><description>https://twitter.com/retrage/status/1608981455182651392 こういう不安を感じたので、心の安寧を取り戻すために今月と今年に何をやったのかをまとめてみる。なお、自分の中で「取り組んでいることを話題にす</description></item><item><title>Allwinner NezhaにJTAGで接続する</title><link>https://retrage.github.io/2022/01/16/allwinner-nezha-jtag.html/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2022/01/16/allwinner-nezha-jtag.html/</guid><description>Allwinner NezhaはD1という64-bit RISC-VなSoCが載ったSBCである。Linuxがちゃんと動くRISC-Vマシンとしてはかなり安価な</description></item><item><title>Apple File Systemの下にはEFI driverが埋まっている</title><link>https://retrage.github.io/2021/09/18/apfs-efi-jumpstart.html/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2021/09/18/apfs-efi-jumpstart.html/</guid><description>Apple File Systemの下にはEFI driverが埋まっている Apple File System (APFS)はAppleが自社製品向けに開発したファイルシステムである．APF</description></item><item><title>9pfsPkg: Network Boot from Bell Labs</title><link>https://retrage.github.io/2020/08/01/9pfspkg-en.html/</link><pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2020/08/01/9pfspkg-en.html/</guid><description>I developed a Plan 9 file system (9P) client for UEFI to enable network booting from a commodity 9P server. By leveraging the simplicity and flexibility of 9P, the UEFI can do network boot from cloud storage without any effort. This blog post gives you a brief overview of 9pfsPkg.
The source code, introduction slides, and presentation video are available at:
https://github.com/yabits/9pfsPkg https://speakerdeck.com/retrage/network-boot-from-bell-labs https://youtu.be/3PX19nWrygQ What is Network Boot? Network boot is a boot method which loading boot images over the network.</description></item><item><title>UEFI向け9P File Systemを作ってクラウドからネットワークブートできるようにした</title><link>https://retrage.github.io/2020/06/15/9pfspkg.html/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2020/06/15/9pfspkg.html/</guid><description>UEFI向け9P File Systemを実装した． これにより9Pサーバからネットワークブートができるようになった． さらにFUSEと組み合わせることで</description></item><item><title>Linux Kernel Library Nabla Containers Internals</title><link>https://retrage.github.io/2020/05/11/lkl-nabla-internals.html/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2020/05/11/lkl-nabla-internals.html/</guid><description>This post describes the design and implementation of Linux Kernel Library Nabla Containers (LKL Nabla), Linux based unikernels as processes. The previous post introduces LKL Nabla and provides how to build and run. Since most of the unikernel work is done by frankenlibc LKL/musl, mainly focus on frankenlibc Solo5 port in this post.
You can find LKL Nabla code at:
https://github.com/retrage/runnc/tree/lkl-musl https://github.com/retrage/frankenlibc/tree/solo5 Modifications to runnc Before diving into frankenlibc code, let’s take a look at the modifications to runnc.</description></item><item><title>EDK2におけるDebugPrintErrorLevel</title><link>https://retrage.github.io/2020/05/06/edk2-error-level.html/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2020/05/06/edk2-error-level.html/</guid><description>EDK2のコードにはDebugPrint()が多く埋め込まれている． この関数は第一引数にErrorLevelをとり， ビルド時に与えるPcdD</description></item><item><title>Porting Linux to Nabla Containers</title><link>https://retrage.github.io/2020/04/18/lkl-nabla-en.html/</link><pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2020/04/18/lkl-nabla-en.html/</guid><description>This is an introduction of Linux Kernel Library ported to Nabla Containers.
runnc is an OCI runtime that runs process-level isolated unikernels. It is built on the top of Solo5, a sandbox for unikernels, and several unikernels (MirageOS, IncludeOS, Rumprun) run on it. The original runnc uses Rumprun, a NetBSD based unikernel. However, as Docker is started from Linux, it is needed to have system call level compatibility with Linux. Therefore, I ported Linux Kernel Library (LKL) and musl libc to Solo5 and put together with runnc.</description></item><item><title>ccov: printfデバッグを支援するツール</title><link>https://retrage.github.io/2020/03/04/ccov-introduction.html/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2020/03/04/ccov-introduction.html/</guid><description>ここではコードカバレッジ計測を元にしたprintfデバッグ支援ツールであるccovを作ったので紹介する． コードは以下で公開している． https://github.com/retrage/ccov gcov, ll</description></item><item><title>Debugging OVMF with GDB</title><link>https://retrage.github.io/2019/12/05/debugging-ovmf-en.html/</link><pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/12/05/debugging-ovmf-en.html/</guid><description>In this blog post, I will describe how to debug OVMF using GDB without any special tool unlike another post[1].
Code Mapping in UEFI On x64 UEFI, it provides flat single address memory space and place the firmware itself and UEFI images on the space without any memory protection. In this way, we can do source code level debugging any UEFI code with debugger. On OVMF, each feature is modularized and the module is loaded as UEFI image.</description></item><item><title>EFI_STATUSの値</title><link>https://retrage.github.io/2019/11/26/efi-status-code.html/</link><pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/11/26/efi-status-code.html/</guid><description>毎回EFI_STATUSの値を調べるのが手間なのでここでまとめておく． TL;DR EFI_STATUS Value (64-bit) EFI_SUCCESS 0x0 EFI_LOAD_ERROR 0x8000000000000001 EFI_INVALID_PARAMETER 0x8000000000000002 EFI_UNSUPPORTED 0x8000000000000003 EFI_BAD_BUFFER_SIZE 0x8000000000000004 EFI_BUFFER_TOO_SMALL 0x8000000000000005 EFI_NOT_READY 0x8000000000000006 EFI_DEVICE_ERROR 0x8000000000000007 EFI_WRITE_PROTECTED 0x8000000000000008 EFI_OUT_OF_RESOURCES 0x8000000000000009 EFI_VOLUME_CORRUPTED 0x800000000000000a EFI_VOLUME_FULL 0x800000000000000b EFI_NO_MEDIA 0x800000000000000c EFI_MEDIA_CHANGED 0x800000000000000d EFI_NOT_FOUND 0x800000000000000e EFI_ACCESS_DENIED</description></item><item><title>OVMFのデバッグ</title><link>https://retrage.github.io/2019/11/05/debugging-ovmf.html/</link><pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/11/05/debugging-ovmf.html/</guid><description>ここではgdbを用いたOVMFのデバッグ方法について説明する． すでにOVMFのデバッグについて書かれた記事[1]が存在するが， ここでは特別な</description></item><item><title>LLVMのEFI Byte Codeバックエンドを作る</title><link>https://retrage.github.io/2019/07/20/llvm-backend-for-ebc.html/</link><pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/07/20/llvm-backend-for-ebc.html/</guid><description>ここでは開発しているLLVMのEFI Byte Code (EBC)バックエンドの概要と EBCバックエンド固有の問題などについてみていく． ソースコードは以下で</description></item><item><title>文鎮化したMinnowboardを復旧させる</title><link>https://retrage.github.io/2019/07/14/bricked-minnowboard.html/</link><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/07/14/bricked-minnowboard.html/</guid><description>MinnowboardはIntel Atomを搭載した シングルボードコンピュータである． Minnowboardを使った実験で誤ったファームウェ</description></item><item><title>ELVMのEFI Byte Codeバックエンドを作る</title><link>https://retrage.github.io/2019/07/13/elvm-ebc.html/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/07/13/elvm-ebc.html/</guid><description>ここでは ELVM のEFI Byte Codeバックエンドについて紹介する． 特にELVM IRとEFI Byte Codeのsemantic gapに注目する． EFI Byte Code</description></item><item><title>Librarizing Linux kernel for Unikernels</title><link>https://retrage.github.io/2019/06/02/lkl-on-unikraft-en.html/</link><pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/06/02/lkl-on-unikraft-en.html/</guid><description>I ported the Linux kernel to Unikraft as an external library. This makes it possible to reuse the rich functions of the Linux kernel for Unikernel with less functionality. In this blog post, I describe the overview of the library.
Background Linux Kernel Library The Linux kernel is a well-maintained mature open source OS kernel. Recently, there have been researches that propose reuse its components. The Linux Kernel Library (LKL) is one of them, which uses the Linux kernel as a form of Library OS with minimum modifications.</description></item><item><title>Linux kernelをUnikernelのライブラリ化する</title><link>https://retrage.github.io/2019/05/30/lkl-on-unikraft.html/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/05/30/lkl-on-unikraft.html/</guid><description>Linux kernelをUnikraftのライブラリ化した． これにより機能の少ないUnikernelの資源として Linux kernelの持つ機能を利用するこ</description></item><item><title>正規表現からLLVM IRを生成する</title><link>https://retrage.github.io/2019/05/12/regex-to-llvm-ir.html/</link><pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/05/12/regex-to-llvm-ir.html/</guid><description>正規表現からLLVM IRを生成する 正規表現は文字列マッチングなどに広く用いられている形式言語であるが， 等価な決定性有限オートマトン(DFA)</description></item><item><title>技術書典6で新刊「UEFI読本 GRUB編」を頒布</title><link>https://retrage.github.io/2019/04/13/efi-book2-ad.html/</link><pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2019/04/13/efi-book2-ad.html/</guid><description>技術書典6で新刊「UEFI読本 GRUB編」を頒布 2019年4月14日に池袋サンシャインシティで開催される 技術書典6において「海洋軟件」として</description></item><item><title>LinuxにおけるEFI Variableをみてみる</title><link>https://retrage.github.io/2018/12/20/linux-efivars.html/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/12/20/linux-efivars.html/</guid><description>LinuxにおけるEFI Variableをみてみる この記事は Linux Advent Calendar 2018 の20日目の記事として書かれた． ここではLinux kerenlにおけるE</description></item><item><title>ebcvm: A Usermode EFI Byte Code Virtual Machine</title><link>https://retrage.github.io/2018/12/19/introduction-to-ebcvm.html/</link><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/12/19/introduction-to-ebcvm.html/</guid><description>この記事は 自作OS Advent Calendar 2018 の19日目の記事として書かれた． ここでは，フルスクラッチで開発したEFI Byte Code Virtual Machineである ebcvm[1]と</description></item><item><title>EFI Byte Code解説</title><link>https://retrage.github.io/2018/11/11/efi-byte-code-myth.html/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/11/11/efi-byte-code-myth.html/</guid><description>本記事は2018年11月10日に開催されたkernelvm 北陸 Part4において 発表した内容[10]をまとめたものである． ここではUEFIの</description></item><item><title>EFI stubなArch Linuxのインストール</title><link>https://retrage.github.io/2018/10/13/efi-stub-install.html/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/10/13/efi-stub-install.html/</guid><description>QEMU上の仮想マシンにEFI stubなArch Linuxをインストールする。 ここでのホストはUbuntu 16.04.4 TLSとする。 なお[1][2][</description></item><item><title>技術書典5で「UEFI読本 基礎編 Linux編」を頒布</title><link>https://retrage.github.io/2018/10/01/efi-book-ad.html/</link><pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/10/01/efi-book-ad.html/</guid><description>2018年10月8日に池袋サンシャインシティで開催される 技術書典5において「海洋軟件」として 「UEFI読本 基礎編 Linux編」を頒布する． 配</description></item><item><title>LKL.js: Running Linux Kernel on JavaScript *Directly*</title><link>https://retrage.github.io/2018/07/25/lkl-js-en.html/</link><pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/07/25/lkl-js-en.html/</guid><description>I ported Linux kernel directly on JavaScript. In other words, I translated the Linux kernel to JavaScript using Emscripten, and Unlike JSLinux, it runs without emulators.
The following is the working repository.
https://github.com/retrage/linux/tree/retrage/em-v2 I published a demonstration site for LKL.js. Please enable SharedArrayBuffer and try it out
LKL.js Demo I also published slides about LKL.js.
https://speakerdeck.com/retrage/lkl-dot-js-running-linux-kernel-on-javascript-star-directly-star Linux Kernel Library (LKL) We use Linux Kernel Library (LKL) which makes the Linux kernel an anykernel.</description></item><item><title>LKL.js: Linux kernelを直接JavaScript上で動かす</title><link>https://retrage.github.io/2018/07/21/lkl-js.html/</link><pubDate>Sat, 21 Jul 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/07/21/lkl-js.html/</guid><description>Linux kernelを直接JavaScript上で動かした． つまり，JSLinuxのようにEmulatorをJavaScriptで作成し， その上で</description></item><item><title>HiFive1でZephyr</title><link>https://retrage.github.io/2018/06/26/zephyr-on-hifive1.html/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/06/26/zephyr-on-hifive1.html/</guid><description>HiFive1とは，SiFiveによって開発されたRISC-V搭載のArduino互換ボードである． 一方，Zephyrは，Linux Foun</description></item><item><title>RustでBrainfuck処理系を高速化して遊んでみる</title><link>https://retrage.github.io/2018/06/18/brainfuck-performance.html/</link><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/06/18/brainfuck-performance.html/</guid><description>Brainfuckとは&amp;gt;&amp;lt;+-.,[]の8つの命令からなるプログラミング言語である． 実装が簡単であるために，すでに多くの言語によ</description></item><item><title>8cc in Lazy K</title><link>https://retrage.github.io/2018/04/01/8cc-lazyk.html/</link><pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/04/01/8cc-lazyk.html/</guid><description>本日は4月1日で，エイプリルフールの日である． ただ，書いている現在は午後9時で，ちょっと嘘をつくには遅すぎる時間である．そこで，今回は何にも</description></item><item><title>Google V8 JavaScript EngineでのWebAssemblyのi32.addの実装を見てみる</title><link>https://retrage.github.io/2018/03/04/v8-wasm-i32add-internal.html/</link><pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2018/03/04/v8-wasm-i32add-internal.html/</guid><description>WebAssembly(以下，wasm)については，既に多くの解説記事が存在するため， wasmについての説明は割愛する． ここでは，wasmが</description></item><item><title>Rustでcoreboot payload</title><link>https://retrage.github.io/2017/12/18/coreboot-ffi.html/</link><pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/12/18/coreboot-ffi.html/</guid><description>この記事は自作OS Advent Calendar の19日目の記事として書かれた． ここでは，corebootのpayloadをRustを使って作ってみる． coreboo</description></item><item><title>Linux kernelの5-Level Paging有効化部分を読んでみる</title><link>https://retrage.github.io/2017/12/13/five-level-paging.html/</link><pubDate>Wed, 13 Dec 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/12/13/five-level-paging.html/</guid><description>この記事はLinux Advent Calendar 14日目の記事として書かれた． 本記事ではLinuxにおける5-Level Paging(la57 paging)の実装を見ていく． 5-Level Pagi</description></item><item><title>EFI stubなLinux kernelのヘッダ部分を見てみる</title><link>https://retrage.github.io/2017/12/09/efi-stub-header.html/</link><pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/12/09/efi-stub-header.html/</guid><description>EFI環境においてLinux kernelの起動方法には ブートローダを用いる方法とEFI stubの2通りがある． EFI stubではbzImageに</description></item><item><title>BitVisorのEFI向け VMM Loader(1st stage)のコードを読んでみる</title><link>https://retrage.github.io/2017/12/07/bitvisor-efi-loader.html/</link><pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/12/07/bitvisor-efi-loader.html/</guid><description>この記事は BitVisor Advent Calendar 7日目の記事として書かれた． ここでは，BitVisorのEFI向け VMMLoader(1st stage)のコードを読んでみる． EFI Loaderのコード</description></item><item><title>Windows 10にEZP2010のドライバをインストール</title><link>https://retrage.github.io/2017/11/09/windows10-ezp2010-driver.html/</link><pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/11/09/windows10-ezp2010-driver.html/</guid><description>EZP2010はAmazonなどで安価に販売されているROMライタである． すでに公式のWebサイトが閉鎖されていたりして Windows 10のドライバは公</description></item><item><title>BitbucketとCircle CIでLatexする</title><link>https://retrage.github.io/2017/08/29/bitbucket-circleci.html/</link><pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/08/29/bitbucket-circleci.html/</guid><description>前回からだいぶ空いてしまったが，小ネタを投下する． 以前に， Jenkins+Bitbucket(Git)でLaTeX という記事を書いた． ここで</description></item><item><title>ELVMのLLVM IRバックエンドをつくった</title><link>https://retrage.github.io/2017/03/25/elvm-llvm-ir.html/</link><pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2017/03/25/elvm-llvm-ir.html/</guid><description>LLVMはよく知られてるコンパイラ基盤であり， 中間表現としてLLVM IRを持っている． 様々なところでこのLLVM IRが使われているが， 今まで</description></item><item><title>Zephyr上でBrainfuckを(一部)動かしてみる</title><link>https://retrage.github.io/2016/03/02/zephyr-brainfuck.html/</link><pubDate>Wed, 02 Mar 2016 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2016/03/02/zephyr-brainfuck.html/</guid><description>ZephyrはLinux Foundationが発表したのRTOSである。 ただ触ってみただけでは面白くないので、 ここではZephyr上で動作す</description></item><item><title>OpenBSD vmmを動かしてみる</title><link>https://retrage.github.io/2016/02/17/vmm-introduction.html/</link><pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2016/02/17/vmm-introduction.html/</guid><description>vmmはOpenBSD上で開発されているVMM(Virtual Machine Monitor)である。 ここではvmmを実際に動かしてその上でOpenBSD</description></item><item><title>u8glibを使って画像をArduinoに接続したLCDに表示</title><link>https://retrage.github.io/2016/01/07/u8glib-image-arduino.html/</link><pubDate>Thu, 07 Jan 2016 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2016/01/07/u8glib-image-arduino.html/</guid><description>タイトル通り、aitendoのFSTN液晶モジュールに画像を出力させてみました。 FSTN液晶モジュールには8x8ピクセル単位で配列として画像</description></item><item><title>BeagleBoneBlack上でUEFIを動かしてみる</title><link>https://retrage.github.io/2015/11/09/uefi-on-beagleboneblack.html/</link><pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2015/11/09/uefi-on-beagleboneblack.html/</guid><description>BeagleBoneBlack(以下、BBB)実機上でUEFIを動かしてみます。 前回の記事ではBeagleBoardでしたが、ここではBBB</description></item><item><title>EDK2のクロスコンパイル</title><link>https://retrage.github.io/2015/11/08/cross-compile-edk2.html/</link><pubDate>Sun, 08 Nov 2015 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2015/11/08/cross-compile-edk2.html/</guid><description>tianocore/edk2をx64上でARM向けにクロスコンパイルしてみました。 ここでは、EDK2のリポジトリにあるBeagleBoard</description></item><item><title>QEMUでARM向けUEFIを動かしてみる</title><link>https://retrage.github.io/2015/11/08/uefi-for-arm-on-qemu.html/</link><pubDate>Sun, 08 Nov 2015 00:00:00 +0000</pubDate><guid>https://retrage.github.io/2015/11/08/uefi-for-arm-on-qemu.html/</guid><description>QEMUのBeagleBoardエミュレータでEDK2のBeagleBoardPkgを動かしてみます。 BeagleBoardPkgはLinu</description></item><item><title>About</title><link>https://retrage.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://retrage.github.io/about/</guid><description>Akira Moroo I am a software engineer. I am also interested in operating systems, and compilers. Previously I have researched in natural language processing, software engineering, and firmware security, especially x86 and RISC-V. You can find my e-mail address on the bottom of this page.
Works 9pfsPkg, 9P Client File System for UEFI frankenlibc on Solo5 EFI Byte Code Backend for LLVM LKL on Unikraft, Librarizing Linux Kernel for Unikernel EBC Backend for ELVM Rust Backend for ELVM ebcvm, EFI Byte Code Virtual Machine LKL.</description></item></channel></rss>