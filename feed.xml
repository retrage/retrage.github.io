<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-06-26T23:22:43+09:00</updated><id>http://localhost:4000/</id><title type="html">めもちょー</title><subtitle>Mirror of http://retrage01.hateblo.jp/ Blog post in Japanese by @retrage01</subtitle><entry><title type="html">HiFive1でZephyr</title><link href="http://localhost:4000/2018/06/26/zephyr-on-hifive1.html" rel="alternate" type="text/html" title="HiFive1でZephyr" /><published>2018-06-26T23:19:50+09:00</published><updated>2018-06-26T23:19:50+09:00</updated><id>http://localhost:4000/2018/06/26/zephyr-on-hifive1</id><content type="html" xml:base="http://localhost:4000/2018/06/26/zephyr-on-hifive1.html">&lt;p&gt;HiFive1とは，SiFiveによって開発されたRISC-V搭載のArduino互換ボードである．
一方，Zephyrは，Linux Foundationにより開発が進められている組み込み向けOSである．
upstreamのZephyrはHiFive1に対応している．
ここでは，ZephyrをHiFive1向けにビルドしてみる．&lt;/p&gt;

&lt;p&gt;ホスト環境はx86_64で&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Distributor ID:	Ubuntu
Description:	Ubuntu 16.04.4 LTS
Release:	16.04
Codename:	xenial
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;である．&lt;/p&gt;

&lt;h2 id=&quot;risc-v向けtoolchainのビルド&quot;&gt;RISC-V向けtoolchainのビルド&lt;/h2&gt;

&lt;p&gt;最初にRISC-V向けのtoolchainをビルドする．&lt;/p&gt;

&lt;p&gt;基本的に以下のREADME通り．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/riscv/riscv-gnu-toolchain&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
$ sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ここでは&lt;code class=&quot;highlighter-rouge&quot;&gt;$HOME/rv32&lt;/code&gt;以下にインストールすることとする．
ターゲットのHiFive1は&lt;code class=&quot;highlighter-rouge&quot;&gt;32-bit RV32IMAC&lt;/code&gt;である．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./configure --prefix=$HOME/rv32 --with-arch=rv32imac --with-abi=ilp32d
$ make linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;zephyrの取得と環境構築&quot;&gt;Zephyrの取得と環境構築&lt;/h2&gt;

&lt;p&gt;以下の通り，必要となるパッケージをインストールする．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://docs.zephyrproject.org/getting_started/installation_linux.html&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/zephyrproject-rtos/zephyr.git
$ sudo apt install git cmake ninja-build gperf ccache doxygen dfu-util device-tree-compiler python3-ply python3-pip python3-setuptools python3-wheel xz-utils file make gcc-multilib autoconf automake libtool
$ cd zephyr
$ pip3 install --user -r scripts/requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;applicationのビルド&quot;&gt;Applicationのビルド&lt;/h2&gt;

&lt;p&gt;以下の通り，環境変数を与える．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd hello/build
$ export ZEPHYR_BASE=~/src/zephyr
$ export BOARD=&quot;hifive1&quot;
$ export ZEPHYR_TOOLCHAIN_VARIANT=riscv32
$ export GCCRISCV32_TOOLCHAIN_PATH=~/rv32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cmake &quot;Unix Makefies&quot; ..
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これで，ビルドされ&lt;code class=&quot;highlighter-rouge&quot;&gt;build/zephyr/zephyr.elf&lt;/code&gt;が生成される．&lt;/p&gt;</content><author><name></name></author><summary type="html">HiFive1とは，SiFiveによって開発されたRISC-V搭載のArduino互換ボードである． 一方，Zephyrは，Linux Foundationにより開発が進められている組み込み向けOSである． upstreamのZephyrはHiFive1に対応している． ここでは，ZephyrをHiFive1向けにビルドしてみる．</summary></entry><entry><title type="html">RustでBrainfuck処理系を高速化して遊んでみる</title><link href="http://localhost:4000/2018/06/18/brainfuck-performance.html" rel="alternate" type="text/html" title="RustでBrainfuck処理系を高速化して遊んでみる" /><published>2018-06-18T22:37:02+09:00</published><updated>2018-06-18T22:37:02+09:00</updated><id>http://localhost:4000/2018/06/18/brainfuck-performance</id><content type="html" xml:base="http://localhost:4000/2018/06/18/brainfuck-performance.html">&lt;p&gt;Brainfuckとは&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;lt;+-.,[]&lt;/code&gt;の8つの命令からなるプログラミング言語である．
実装が簡単であるために，すでに多くの言語によって実装がなされている．
ここでは，
&lt;a href=&quot;https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter.html&quot;&gt;Adventures in JIT compilation: Part 1 - an interpreter&lt;/a&gt;
を参考にC++の実装をRustに移植し，そのパフォーマンスを計測し，比較をして遊んでみる．&lt;/p&gt;

&lt;h2 id=&quot;brainfuckの実装&quot;&gt;Brainfuckの実装&lt;/h2&gt;

&lt;p&gt;実装したBrainfuckは&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;simpleinterp&lt;/li&gt;
  &lt;li&gt;optinterp&lt;/li&gt;
  &lt;li&gt;optinterp2&lt;/li&gt;
  &lt;li&gt;optinterp3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の4通りがある．&lt;/p&gt;

&lt;p&gt;simpleinterpは素朴な実装であり，高速化はなされていない．
optinterpは&lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;の対応表を実行時に作成することにより最適化を図っている．
optinterp2は8つの命令に加えて高水準な命令を定義し，
局所的に実行される命令をそれらの命令に置き換えることで最適化を行う．
optinterp3はさらに実行されるループに使われるパターンを高水準な命令に置き換え，最適化を行う．&lt;/p&gt;

&lt;p&gt;実装の概要については
&lt;a href=&quot;https://speakerdeck.com/retrage/brainf-star-ckfalsegao-su-hua-1&quot;&gt;BrainFuckの高速化&lt;/a&gt;
において解説している．&lt;/p&gt;

&lt;h2 id=&quot;ベンチマークと計測方法&quot;&gt;ベンチマークと計測方法&lt;/h2&gt;

&lt;p&gt;先に挙げたブログ内では
&lt;code class=&quot;highlighter-rouge&quot;&gt;mandelbrot&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;factor&lt;/code&gt;の2つのスクリプトをベンチマークに用いている．
ここでもこれらのスクリプトを用いることとする．&lt;/p&gt;

&lt;p&gt;実行速度の計測には&lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt;を用いる．
計測時には&lt;code class=&quot;highlighter-rouge&quot;&gt;--release&lt;/code&gt;オプションを指定し，最適化がなされるようにした．&lt;/p&gt;

&lt;p&gt;実行環境は&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MacBook Air (11-inch, Early 2014)
CPU: 1.7 GHz Intel Core i7
RAM: 8GB 1600 MHz DDR3
OS: macOS High Sierra 10.13.5
cargo: 1.26.0
rustc: 1.26.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;である．&lt;/p&gt;

&lt;h2 id=&quot;mandelbrot&quot;&gt;mandelbrot&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mandelbrot&lt;/code&gt;の場合の比較．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;simpleinterp: cargo run --release mandelbrot.bf  47.78s user 0.14s system 99% cpu 48.037 total
optinterp:    cargo run --release mandelbrot.bf  25.90s user 0.10s system 99% cpu 26.080 total
optinterp2:   cargo run --release mandelbrot.bf  8.30s user 0.08s system 99% cpu 8.443 total
optinterp3:   cargo run --release mandelbrot.bf  6.46s user 0.09s system 99% cpu 6.617 total
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/bf-perf-mandelbrot.png&quot; alt=&quot;Mandelbrot Performance&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;factor&quot;&gt;factor&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;factor&lt;/code&gt;の場合の比較&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;simpleinterp: cargo run --release factor.bf &amp;lt; prime  17.16s user 0.10s system 99% cpu 17.321 total
optinterp:    cargo run --release factor.bf &amp;lt; prime  9.64s user 0.09s system 99% cpu 9.790 total
optinterp2:   cargo run --release factor.bf &amp;lt; prime  3.45s user 0.09s system 98% cpu 3.611 total
optinterp3:   cargo run --release factor.bf &amp;lt; prime  2.93s user 0.07s system 98% cpu 3.039 total
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/bf-perf-factor.png&quot; alt=&quot;Factor Performace&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いずれのスクリプトの場合でも
simpleinterp &amp;gt; optinterp &amp;gt; optinterp2 &amp;gt; optinterp3
の順の実行時間であった．これは元記事とも一致する．
さらに元記事のようにJITなどを用いて最適化することも考えられる．&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter.html&lt;/li&gt;
  &lt;li&gt;https://github.com/retrage/brainfuck-rs&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Brainfuckとは&amp;gt;&amp;lt;+-.,[]の8つの命令からなるプログラミング言語である． 実装が簡単であるために，すでに多くの言語によって実装がなされている． ここでは， Adventures in JIT compilation: Part 1 - an interpreter を参考にC++の実装をRustに移植し，そのパフォーマンスを計測し，比較をして遊んでみる．</summary></entry><entry><title type="html">8cc in Lazy K</title><link href="http://localhost:4000/2018/04/01/8cc-lazyk.html" rel="alternate" type="text/html" title="8cc in Lazy K" /><published>2018-04-01T21:17:53+09:00</published><updated>2018-04-01T21:17:53+09:00</updated><id>http://localhost:4000/2018/04/01/8cc-lazyk</id><content type="html" xml:base="http://localhost:4000/2018/04/01/8cc-lazyk.html">&lt;p&gt;本日は4月1日で，エイプリルフールの日である．
ただ，書いている現在は午後9時で，ちょっと嘘をつくには遅すぎる時間である．そこで，今回は何にも役に立たないものを作ってみようと思った．
そこで，表題の通り，Lazy Kで書かれた8ccを生成して遊んでみた．&lt;/p&gt;

&lt;h2 id=&quot;生成&quot;&gt;生成&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shinh/bflisp/blob/master/8cc.bf&quot;&gt;ELVMで生成された8cc.bf&lt;/a&gt;
をダウンロード&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/msullivan/LazyK/blob/master/eg/bf2lazy.c&quot;&gt;bf2lazy.c&lt;/a&gt;
をダウンロード&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;2.で1.をLazy Kに変換
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc bf2lazy.c -o bf2lazy
./bf2lazy &amp;lt; 8cc.bf &amp;gt; 8cc.bf.lazy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;生成されたLazy Kのコード
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ du -h 8cc.bf.lazy
 12G	8cc.bf.lazy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;バカみたいにでかくなる．&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;検証&quot;&gt;検証&lt;/h2&gt;
&lt;p&gt;おそらくは正しく動くはずであるが，8cc.bfだけで検証するのが相当かかるようなので，8cc.bf.lazyではさらに検証に時間がかかるはずなので，やらないこととする．&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;適当にやったらLazy Kのコードがバカでかくなった．
生成されたコードは無用の長物なので，どこにもあげないが，簡単に生成できるので，暇な人はやってみよう．&lt;/p&gt;</content><author><name></name></author><summary type="html">本日は4月1日で，エイプリルフールの日である． ただ，書いている現在は午後9時で，ちょっと嘘をつくには遅すぎる時間である．そこで，今回は何にも役に立たないものを作ってみようと思った． そこで，表題の通り，Lazy Kで書かれた8ccを生成して遊んでみた．</summary></entry><entry><title type="html">Google V8 JavaScript EngineでのWebAssemblyのi32.addの実装を見てみる</title><link href="http://localhost:4000/2018/03/04/v8-wasm-i32add-internal.html" rel="alternate" type="text/html" title="Google V8 JavaScript EngineでのWebAssemblyのi32.addの実装を見てみる" /><published>2018-03-04T14:43:55+09:00</published><updated>2018-03-04T14:43:55+09:00</updated><id>http://localhost:4000/2018/03/04/v8-wasm-i32add-internal</id><content type="html" xml:base="http://localhost:4000/2018/03/04/v8-wasm-i32add-internal.html">&lt;p&gt;WebAssembly(以下，wasm)については，既に多くの解説記事が存在するため，
wasmについての説明は割愛する．
ここでは，wasmがどのように実装され，実行されるのかを見ていく．
参照する実装はGoogle V8 JavaScript Engineの
&lt;code class=&quot;highlighter-rouge&quot;&gt;1b254a25163fd84a7696ff62e87cb6dcde7e13f2&lt;/code&gt;である．&lt;/p&gt;

&lt;h2 id=&quot;簡単なコード例&quot;&gt;簡単なコード例&lt;/h2&gt;
&lt;p&gt;次のようなwasmのコードを考える．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(module
    (func (param $lhs i32) (param $rhs i32) (result i32)
        get_local $lhs
        get_local $rhs
        i32.add
    )
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;このコードは2つのパラメータを加算して返す関数を表している．
具体的には，パラメータ$lhsと$rhsをスタックにプッシュし，
i32.addによりそれらの加算を行なっている．&lt;/p&gt;

&lt;h2 id=&quot;i32addの実装からたどる&quot;&gt;i32.addの実装からたどる&lt;/h2&gt;
&lt;p&gt;最初にi32.addはどのように実装されているのかを見ていく．
&lt;code class=&quot;highlighter-rouge&quot;&gt;src/wasm/wasm-interpreter.cc&lt;/code&gt;には次のような定義がある．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define FOREACH_SIMPLE_BINOP(V) \
  V(I32Add, uint32_t, +)        \
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I32Add&lt;/code&gt;とあるので，ここがi32.addの定義であることがわかる．
次に&lt;code class=&quot;highlighter-rouge&quot;&gt;FOREACH_SIMPLE_BINOP&lt;/code&gt;が使われている部分を見る．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define EXECUTE_SIMPLE_BINOP(name, ctype, op)               \
  case kExpr##name: {                                       \
    WasmValue rval = Pop();                                 \
    WasmValue lval = Pop();                                 \
    auto result = lval.to&amp;lt;ctype&amp;gt;() op rval.to&amp;lt;ctype&amp;gt;();     \
    possible_nondeterminism_ |= has_nondeterminism(result); \
    Push(WasmValue(result));                                \
    break;                                                  \
  }
          FOREACH_SIMPLE_BINOP(EXECUTE_SIMPLE_BINOP)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EXECUTE_SIMPLE_BINOP&lt;/code&gt;を引数として&lt;code class=&quot;highlighter-rouge&quot;&gt;FOREACH_SIMPLE_BINOP&lt;/code&gt;を
呼び出していることがわかる．
ここでは，何らかのcase文となっておりその中で，
スタックから値をポップしrvalとlvalに代入し，与えられたopで計算を行い，
resultに代入し，値をプッシュしていることがわかる．
つまり，ここで実際の計算が行われていることがわかる．&lt;/p&gt;

&lt;p&gt;では，このcase文の大元を見てみる．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      switch (orig) {
        case kExprNop:
          break;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ここから，origにより判定していることがわかる．
origは&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte orig = code-&amp;gt;start[pc];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;であり，codeは&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void Execute(InterpreterCode* code, pc_t pc, int max) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;から&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute&lt;/code&gt;の引数であることがわかる．
さらに，&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute&lt;/code&gt;は&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  WasmInterpreter::State Run(int num_steps = -1) {
    DCHECK(state_ == WasmInterpreter::STOPPED ||
           state_ == WasmInterpreter::PAUSED);
    DCHECK(num_steps == -1 || num_steps &amp;gt; 0);
    if (num_steps == -1) {
      TRACE(&quot;  =&amp;gt; Run()\n&quot;);
    } else if (num_steps == 1) {
      TRACE(&quot;  =&amp;gt; Step()\n&quot;);
    } else {
      TRACE(&quot;  =&amp;gt; Run(%d)\n&quot;, num_steps);
    }
    state_ = WasmInterpreter::RUNNING;
    Execute(frames_.back().code, frames_.back().pc, num_steps);
    // If state_ is STOPPED, the current activation must be fully unwound.
    DCHECK_IMPLIES(state_ == WasmInterpreter::STOPPED,
                   current_activation().fp == frames_.size());
    return state_;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;より&lt;code class=&quot;highlighter-rouge&quot;&gt;WasmInterpreter::State Run&lt;/code&gt;から呼び出されている．
コードを追うのは一旦このあたりでやめておく．&lt;/p&gt;

&lt;h2 id=&quot;スタックの実装&quot;&gt;スタックの実装&lt;/h2&gt;
&lt;p&gt;wasmはスタックマシンとなっている．ここでは，これまでで出てきた関数
&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;からスタックの実装をみていく．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  WasmValue Pop() {
    DCHECK_GT(frames_.size(), 0);
    DCHECK_GT(StackHeight(), frames_.back().llimit());  // can't pop into locals
    return *--sp_;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void Push(WasmValue val) {
    DCHECK_NE(kWasmStmt, val.type());
    DCHECK_LE(1, stack_limit_ - sp_);
    *sp_++ = val;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;，いずれも実装はたったの1行だけであることがわかる．&lt;/p&gt;

&lt;p&gt;以上，Google V8 JavaScript Engineでのwasmの実装を簡単に見ていった．
正直なところ，最適化などで非常に複雑かつ高度な実装になっていると思っていたが，
今回読んだ部分はナイーブな実装となっており，読みやすいといえる．
一方で，JavaScriptとのインターフェースとなる部分は相当複雑であることが
容易に想像できる．&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://webassembly.github.io/spec/core/index.html&lt;/li&gt;
  &lt;li&gt;https://developer.mozilla.org/ja/docs/WebAssembly/Understanding_the_text_format&lt;/li&gt;
  &lt;li&gt;https://github.com/v8/v8/blob/master/src/wasm/wasm-interpreter.cc&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">WebAssembly(以下，wasm)については，既に多くの解説記事が存在するため， wasmについての説明は割愛する． ここでは，wasmがどのように実装され，実行されるのかを見ていく． 参照する実装はGoogle V8 JavaScript Engineの 1b254a25163fd84a7696ff62e87cb6dcde7e13f2である．</summary></entry><entry><title type="html">Rustでcoreboot payload</title><link href="http://localhost:4000/2017/12/18/coreboot-ffi.html" rel="alternate" type="text/html" title="Rustでcoreboot payload" /><published>2017-12-18T23:28:27+09:00</published><updated>2017-12-18T23:28:27+09:00</updated><id>http://localhost:4000/2017/12/18/coreboot-ffi</id><content type="html" xml:base="http://localhost:4000/2017/12/18/coreboot-ffi.html">&lt;p&gt;この記事は&lt;a href=&quot;https://adventar.org/calendars/2282&quot;&gt;自作OS Advent Calendar&lt;/a&gt;
の19日目の記事として書かれた．
ここでは，corebootのpayloadをRustを使って作ってみる．
corebootはファームウェアなのでOSとは異なるが，そこはご愛嬌ということで．&lt;/p&gt;

&lt;h2 id=&quot;corebootについて&quot;&gt;corebootについて&lt;/h2&gt;
&lt;p&gt;corebootとは既存のプロプライエタリなBIOSを置き換えるBIOSと
そのプロジェクトのことである．
corebootは大きくcoreboot本体とPayloadの2つがあり，
Payloadには様々なソフトウェアを載せることができる．
今回はPayloadをRustで作ってみようということである．
ここでは，Libpayloadと呼ばれるPayload向けのライブラリの関数を
Rustから呼び出してみる．&lt;/p&gt;

&lt;h2 id=&quot;rustでのベアメタルプログラミング&quot;&gt;Rustでのベアメタルプログラミング&lt;/h2&gt;
&lt;p&gt;Rustでのベアメタルプログラミングについてはκeenさんの&lt;a href=&quot;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&quot;&gt;記事&lt;/a&gt;
が詳しい．ほとんどここを参考にした．&lt;/p&gt;

&lt;p&gt;ホストの環境はx86_64であるとする．
最初に&lt;code class=&quot;highlighter-rouge&quot;&gt;cargo new --bin cb-ffi&lt;/code&gt;とかやって新規のCargoプロジェクトを作成する．&lt;/p&gt;

&lt;p&gt;次に以下のような内容で&lt;code class=&quot;highlighter-rouge&quot;&gt;main.rs&lt;/code&gt;を書く．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#![feature(lang_items, asm)]
#![crate_type = &quot;staticlib&quot;]
#![no_std]

#[link(name = &quot;libpayload&quot;, kind = &quot;static&quot;)]
extern {
    fn putchar(c: u32);
}

#[no_mangle]
pub extern fn main() {
    loop{
        unsafe { putchar(65) };
    }   
}

#[lang = &quot;eh_personality&quot;]
extern fn eh_personality() {}

#[lang = &quot;panic_fmt&quot;]
extern fn panic_fmt() {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ほとんど上記の記事と同じであるが，&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#[link(name = &quot;libpayload&quot;, kind = &quot;static&quot;)]
extern {
    fn putchar(c: u32);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;でlibpayloadの&lt;code class=&quot;highlighter-rouge&quot;&gt;putchar&lt;/code&gt;の参照を定義しており，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#[no_mangle]
pub extern fn main() {
    loop{
        unsafe { putchar(65) };
    }   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;で上記のputcharを呼び出していることがわかる．&lt;/p&gt;

&lt;p&gt;次に&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rustc --target i686-unknown-linux-gnu --emit=obj main.rs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;とかやって&lt;code class=&quot;highlighter-rouge&quot;&gt;main.o&lt;/code&gt;を作成する．&lt;/p&gt;

&lt;p&gt;最後に，あらかじめ作成しておいた&lt;code class=&quot;highlighter-rouge&quot;&gt;libpayload.a&lt;/code&gt;とリンクする．
ここでは，Libpayloadの&lt;code class=&quot;highlighter-rouge&quot;&gt;lpgcc&lt;/code&gt;を用いる．Libpayloadについては
&lt;a href=&quot;https://www.coreboot.org/Libpayload&quot;&gt;ここ&lt;/a&gt;を参照のこと．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/src/coreboot/payloads/libpayload/bin/lpgcc main.o libpayload.a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;できた&lt;code class=&quot;highlighter-rouge&quot;&gt;a.out&lt;/code&gt;をcorebootのPayloadに指定すればできあがり．&lt;/p&gt;

&lt;p&gt;以上，ファームウェアといいつつも，
ただのベアメタルプログラミングであることがわかる．
しかも一切アセンブリに触れずにできていることからも簡単であると言える．&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://keens.github.io/blog/2016/05/04/rustdebeametaruraspberry_pinolchika/&lt;/li&gt;
  &lt;li&gt;https://www.coreboot.org/Libpayload&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">この記事は自作OS Advent Calendar の19日目の記事として書かれた． ここでは，corebootのpayloadをRustを使って作ってみる． corebootはファームウェアなのでOSとは異なるが，そこはご愛嬌ということで．</summary></entry><entry><title type="html">Linux kernelの5-Level Paging有効化部分を読んでみる</title><link href="http://localhost:4000/2017/12/13/five-level-paging.html" rel="alternate" type="text/html" title="Linux kernelの5-Level Paging有効化部分を読んでみる" /><published>2017-12-13T20:22:09+09:00</published><updated>2017-12-13T20:22:09+09:00</updated><id>http://localhost:4000/2017/12/13/five-level-paging</id><content type="html" xml:base="http://localhost:4000/2017/12/13/five-level-paging.html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2017/linux&quot;&gt;Linux Advent Calendar&lt;/a&gt; 
14日目の記事として書かれた．
本記事ではLinuxにおける5-Level Paging(la57 paging)の実装を見ていく．&lt;/p&gt;

&lt;h2 id=&quot;5-level-pagingとは&quot;&gt;5-Level Pagingとは&lt;/h2&gt;
&lt;p&gt;これまで，x86_64では物理アドレス下位48bitのみが使用されてきた．
このため，64TiBの物理アドレス空間と256TiBの仮想アドレス空間に限られてきた．
Intelはこれを拡張し，物理アドレス下位52bitへと拡張させた．
これにより，4PiBの物理アドレス空間と128PiBの仮想アドレス空間が利用できるようになった．
この拡張に対応するため新たに導入されたのが，ここで紹介する5-Level Pagingである．
基本的な考え方は4-Level Pagingと同一であり，
PML4にさらに上位にPML5が追加された形となっている．&lt;/p&gt;

&lt;h2 id=&quot;サポート状況について&quot;&gt;サポート状況について&lt;/h2&gt;
&lt;p&gt;現在，一部のサーバが5-Level Pagingに対応しているようである．
では，個人では触ることができないか，というとそんなことはなく，
QEMUのmasterブランチには5-Level Pagingのエミュレーションが
&lt;a href=&quot;https://github.com/qemu/qemu/commit/6c7c3c21f95dd9af8a0691c0dd29b07247984122#diff-0517790436e7f5831f2b14f1e93ac740&quot;&gt;取り込まれている&lt;/a&gt;．
このため，対応ハードウェアを持っていないくても楽しむことができる．
面白いことに，Library OSの1つであるOSvにおいて，
Avi Kivityさんが5-Level Paging対応のパッチを
&lt;a href=&quot;https://groups.google.com/forum/#!topic/osv-dev/9Y1q0j5qhXI&quot;&gt;投稿している&lt;/a&gt;．&lt;/p&gt;

&lt;h2 id=&quot;5-level-pagingの確認&quot;&gt;5-Level Pagingの確認&lt;/h2&gt;
&lt;p&gt;Linux kernerでコンパイル時に5-Level Pagingを有効にするかを決めているので，
あまり関係がないが一応記しておく．
5-Level Pagingの機能を持っているかどうかはCPUID命令を用いることで確かめることができる．
具体的には&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov $7, %eax
    mov $0, %ecx
    cpuid
    test $1&amp;lt;&amp;lt;16, %ecx /* ? */
    jz .no_5level_paging
    /* 以下，5Level Paging有効化のコード */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;となる．&lt;/p&gt;

&lt;h2 id=&quot;5-level-pagingの有効化&quot;&gt;5-Level Pagingの有効化&lt;/h2&gt;
&lt;p&gt;次に実際に5-Level Pagingを以下のような流れで有効にする．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;現在のPagingとmodeを確認&lt;/li&gt;
  &lt;li&gt;long modeの場合はcompatibility modeなどに切り替える&lt;/li&gt;
  &lt;li&gt;Pagingを無効化&lt;/li&gt;
  &lt;li&gt;PAEとLA57の有効化&lt;/li&gt;
  &lt;li&gt;WRMSRでIA32_EFER.LMEを設定&lt;/li&gt;
  &lt;li&gt;CR3が5-Level Pagingを指すように設定&lt;/li&gt;
  &lt;li&gt;Pagingの有効化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここで注意したい点は，long modeでは直接LA57を変更できない点である．
long modeでLA57を変更しようとした場合，general protection exceptionが発生するようである．&lt;/p&gt;

&lt;h2 id=&quot;linux-kernelでの実装&quot;&gt;Linux kernelでの実装&lt;/h2&gt;
&lt;p&gt;では実際のコードを見ていく．
なお，参照するkernelはtorvalds/linux v4.14 bebc608 である．
&lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/compressed/head_64.S&lt;/code&gt;の&lt;code class=&quot;highlighter-rouge&quot;&gt;startup_64&lt;/code&gt;のコードを見ていく．
おおよそコード内のコメントにある通りであるが，簡単コメントしていく．
ここでは，long modeが有効になっており，まだカーネルが圧縮されている状態である．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	movq	%cr4, %rax
	testl	$X86_CR4_LA57, %eax
	jnz	lvl5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最初にcr4レジスタの値から5-Level Pagingが有効であるかを確認する．
有効でなければ以下を行う．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	leaq	lvl5_pgtable(%rbx), %rdi
	xorq	%rax, %rax
	movq	$(PAGE_SIZE/8), %rcx
	rep	stosq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;追加のPML5のテーブル(lvl5_pgtable)をクリアする．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	movq	%cr3, %rdi
	leaq	0x7 (%rdi), %rax
	movq	%rax, lvl5_pgtable(%rbx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ここでCR3を最初かつ勇逸のトップレベルページテーブルのエントリとするらしい．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	pushq	$__KERNEL32_CS
	leaq	compatible_mode(%rip), %rax
	pushq	%rax
	lretq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;compatibility modeに移行&lt;/p&gt;

&lt;p&gt;compatible_modeの内容は次にようになっている．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	movl	%cr0, %eax
	btrl	$X86_CR0_PG_BIT, %eax
	movl	%eax, %cr0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Pagingを無効&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	leal	lvl5_pgtable(%ebx), %eax
	movl	%eax, %cr3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;CR3がPML5のテーブルを指すように設定&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	movl	%cr4, %eax
	orl	$(X86_CR4_PAE | X86_CR4_LA57), %eax
	movl	%eax, %cr4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;PAEとLA57の有効化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	movl	$(X86_CR0_PG | X86_CR0_PE), %eax
	movl	%eax, %cr0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Pagingの有効化&lt;/p&gt;

&lt;p&gt;以上のような流れとなっている．
意外と短くまとまっていることがわかる．&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://software.intel.com/sites/default/files/managed/2b/80/5-level_paging_white_paper.pdf&lt;/li&gt;
  &lt;li&gt;https://lwn.net/Articles/708526/&lt;/li&gt;
  &lt;li&gt;https://lwn.net/Articles/717293/&lt;/li&gt;
  &lt;li&gt;https://lwn.net/Articles/716324/&lt;/li&gt;
  &lt;li&gt;https://github.com/qemu/qemu/commit/6c7c3c21f95dd9af8a0691c0dd29b07247984122#diff-0517790436e7f5831f2b14f1e93ac740&lt;/li&gt;
  &lt;li&gt;https://groups.google.com/forum/#!topic/osv-dev/9Y1q0j5qhXI&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">この記事はLinux Advent Calendar 14日目の記事として書かれた． 本記事ではLinuxにおける5-Level Paging(la57 paging)の実装を見ていく．</summary></entry><entry><title type="html">EFI stubなLinux kernelのヘッダ部分を見てみる</title><link href="http://localhost:4000/2017/12/09/efi-stub-header.html" rel="alternate" type="text/html" title="EFI stubなLinux kernelのヘッダ部分を見てみる" /><published>2017-12-09T00:12:14+09:00</published><updated>2017-12-09T00:12:14+09:00</updated><id>http://localhost:4000/2017/12/09/efi-stub-header</id><content type="html" xml:base="http://localhost:4000/2017/12/09/efi-stub-header.html">&lt;p&gt;EFI環境においてLinux kernelの起動方法には
ブートローダを用いる方法とEFI stubの2通りがある．
EFI stubではbzImageに対してEFI Application相当のヘッダを付加することで
EFIから直接kernelを起動する．
ここでは，EFI stubなLinux kernelのヘッダが実際に見ることで
どのように直接起動できるようにしているかを見ていく．
実際の記事を書いたのが相当前なので，ここではLinux kernel 4.5を対象としている．&lt;/p&gt;

&lt;p&gt;最初に&lt;code class=&quot;highlighter-rouge&quot;&gt;CONFIG_EFI_STUB=y&lt;/code&gt;としてビルドしたときのbzImageのhexdumpの一部を以下に示す．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000000: 4d5a ea07 00c0 078c c88e d88e c08e d031  MZ.............1
00000010: e4fb fcbe 4000 ac20 c074 09b4 0ebb 0700  ....@.. .t......
00000020: cd10 ebf2 31c0 cd16 cd19 eaf0 ff00 f000  ....1...........
00000030: 0000 0000 0000 0000 0000 0000 8200 0000  ................
00000040: 5573 6520 6120 626f 6f74 206c 6f61 6465  Use a boot loade
00000050: 722e 0d0a 0a52 656d 6f76 6520 6469 736b  r....Remove disk
00000060: 2061 6e64 2070 7265 7373 2061 6e79 206b   and press any k
00000070: 6579 2074 6f20 7265 626f 6f74 2e2e 2e0d  ey to reboot....
00000080: 0a00 5045 0000 6486 0400 0000 0000 0000  ..PE..d.........
00000090: 0000 0100 0000 a000 0602 0b02 0214 4020  ..............@ 
000000a0: 5f00 0000 0000 c0ad e800 1040 0000 0002  _..........@....
000000b0: 0000 0000 0000 0000 0000 2000 0000 2000  .......... ... .
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000d0: 0000 00d0 4701 0002 0000 0000 0000 0a00  ....G...........
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000100: 0000 0000 0000 0600 0000 0000 0000 0000  ................
00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000130: 0000 0000 0000 0000 0000 2e73 6574 7570  ...........setup
00000140: 0000 e03b 0000 0002 0000 e03b 0000 0002  ...;.......;....
00000150: 0000 0000 0000 0000 0000 0000 0000 2000  .............. .
00000160: 5060 2e72 656c 6f63 0000 2000 0000 e03d  P`.reloc.. ....=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;EFI ApplicationはPEフォーマットを採用している．
PEフォーマットではDOSヘッダが最初にあり，次にPEヘッダが置かれている．
それぞれのシグネチャを手がかりに先のhexdumpの結果を見ていく．
最初に0x00に0x4d5a(=”MZ”)があり，DOSヘッダであることを示している．
次に0x3cを見ると，0x0082があり，これがPEヘッダの先頭位置を表している．
0x0082には0x5045(=”PE”)があり．確かにこれがPEヘッダの始まりであることがわかる．
以下、PEヘッダの定義が続くが、ここでは深追いしない．
以上のように，確かにbzImageがEFI Applicationの形式となっていることがわかる．&lt;/p&gt;

&lt;p&gt;ところで．bzImageはgccなどの通常のツールチェーンを用いてビルドされるため，
直接PEフォーマットを出力することはできない．
次にどのようにしてPEフォーマットを出力するのかを見ていく．
最初に&lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/Makefile&lt;/code&gt;の一部を示す．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sed-zoffset := -e 's/^\([0-9a-fA-F]*\) [ABCDGRSTVW] \(startup_32\|startup_64\|efi32_stub_entry\|efi64_stub_entry\|efi_pe_entry\|input_data\|_end\|z_.*\)$$/\#define ZO_\2 0x\1/p'

quiet_cmd_zoffset = ZOFFSET $@
      cmd_zoffset = $(NM) $&amp;lt; | sed -n $(sed-zoffset) &amp;gt; $@

targets += zoffset.h
$(obj)/zoffset.h: $(obj)/compressed/vmlinux FORCE
        $(call if_changed,zoffset)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ここではsedを用いて&lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/compressed/vmlinux&lt;/code&gt;のnmの出力結果から
エントリポイントとなるシンボルのアドレスをzoffset.hに出力していることがわかる．
次に出力されたzoffset.hの一部を示す．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ZO__end 0x0000000000609000
#define ZO_efi64_stub_entry 0x0000000000000390
#define ZO_efi_pe_entry 0x0000000000000210
#define ZO_input_data 0x00000000000003b4
#define ZO_startup_32 0x0000000000000000
#define ZO_startup_64 0x0000000000000200
#define ZO_z_extract_offset 0x0000000000e74000
#define ZO_z_extract_offset_negative 0xffffffffff18c000
#define ZO_z_input_len 0x00000000005e4c23
#define ZO_z_output_len 0x00000000014468b8
#define ZO_z_run_size 0x0000000001553000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ここで特に重要なのは&lt;code class=&quot;highlighter-rouge&quot;&gt;ZO_efi_pe_entry&lt;/code&gt;である．これは後で利用される．
次に&lt;code class=&quot;highlighter-rouge&quot;&gt;src/arch/x86/boot/tools/build.c&lt;/code&gt;(以下，&lt;code class=&quot;highlighter-rouge&quot;&gt;build.c&lt;/code&gt;)を利用する．
これはbzImageを作成するためのツールである．
&lt;code class=&quot;highlighter-rouge&quot;&gt;build.c&lt;/code&gt;は以下の4つの引数をとる．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;setup.bin&lt;/li&gt;
  &lt;li&gt;vmlinux.bin&lt;/li&gt;
  &lt;li&gt;zoffset.h&lt;/li&gt;
  &lt;li&gt;出力先&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.c&lt;/code&gt;の処理を実際にみていく．
ここではPEヘッダのエントリポイントの設定に注目する．
&lt;code class=&quot;highlighter-rouge&quot;&gt;build.c&lt;/code&gt;の一部を示す．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void update_pecoff_text(unsigned int text_start, unsigned int file_sz)
{
        unsigned int pe_header;
        unsigned int text_sz = file_sz - text_start;

        pe_header = get_unaligned_le32(&amp;amp;buf[0x3c]);

        /*
         * Size of code: Subtract the size of the first sector (512 bytes)
         * which includes the header.
         */
        put_unaligned_le32(file_sz - 512, &amp;amp;buf[pe_header + 0x1c]);

        /*
         * Address of entry point for PE/COFF executable
         */
        put_unaligned_le32(text_start + efi_pe_entry, &amp;amp;buf[pe_header + 0x28]);

        update_pecoff_section_header(&quot;.text&quot;, text_start, text_sz);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bufはsetup.binをベースにbzImageの最初の512byteとなる部分である．
pe_headerはbufの0x3cにある32bitを取得する．先のバイナリでは0x0082となる．
次にPEヘッダの&lt;code class=&quot;highlighter-rouge&quot;&gt;Size of code&lt;/code&gt;をbufに書き込む．&lt;/p&gt;

&lt;p&gt;次にPEヘッダの&lt;code class=&quot;highlighter-rouge&quot;&gt;Address Of Entry Point&lt;/code&gt;をbufに書き込む．
text_startはrelocを考慮したときのsetup.binのサイズであり，
efi_pe_entryは先のzoffset.hから得た&lt;code class=&quot;highlighter-rouge&quot;&gt;ZO_efi_pe_entry&lt;/code&gt;の値，0x0210となる．
書き込む位置は&lt;code class=&quot;highlighter-rouge&quot;&gt;[pe_header + 0x28] = 0x82 + 0x28 = 0xaa&lt;/code&gt;となる．
最初に示したhexdumpの0xaaをみると、0x4010が書き込まれている．
ここから，EFIがbzImageを0x4010から実行されることがわかる．&lt;/p&gt;

&lt;p&gt;まとめると，EFIはEFI Applicationをロードすると，
PEヘッダに記載されている&lt;code class=&quot;highlighter-rouge&quot;&gt;Address Of Entry Point&lt;/code&gt;で指定されているアドレスから実行する．
EFI stubなLinux kernelのbzImageの場合，efi_pe_entryから実行されるため，
efi_pe_entryのアドレスが&lt;code class=&quot;highlighter-rouge&quot;&gt;Address Of Entry Point&lt;/code&gt;に入っている必要がある．
&lt;code class=&quot;highlighter-rouge&quot;&gt;build.c&lt;/code&gt;はこのアドレスをsetup.bin，vmlinux.binから算出し，埋め込んでいることがわかった．&lt;/p&gt;

&lt;p&gt;最後にbzImageの0x4010以降とefi_pe_entryとを比較してみる．&lt;/p&gt;

&lt;p&gt;bzImageのhexdumpの結果を示す．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00004010: 4889 0d81 e15e 0048 8915 82e1 5e00 488d  H....^.H....^.H.
00004020: 0573 e15e 0048 8905 64e1 5e00 e800 0000  .s.^.H..d.^.....
00004030: 005d 4881 ed31 0200 0048 012d b0e1 5e00  .]H..1...H.-..^.
00004040: 4889 c7e8 a8a1 5e00 4883 f800 743f 4889  H.....^.H...t?H.
00004050: c648 8d05 a8fd ffff 8986 1402 0000 eb18  .H..............
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/compressed/head64.o&lt;/code&gt;のobjdumpの結果を示す．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0000000000000210 &amp;lt;efi_pe_entry&amp;gt;:
 210:   48 89 0d 00 00 00 00    mov    %rcx,0x0(%rip)        # 217 &amp;lt;efi_pe_entry+0x7&amp;gt;
 217:   48 89 15 00 00 00 00    mov    %rdx,0x0(%rip)        # 21e &amp;lt;efi_pe_entry+0xe&amp;gt;
 21e:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 225 &amp;lt;efi_pe_entry+0x15&amp;gt;
 225:   48 89 05 00 00 00 00    mov    %rax,0x0(%rip)        # 22c &amp;lt;efi_pe_entry+0x1c&amp;gt;
 22c:   e8 00 00 00 00          callq  231 &amp;lt;efi_pe_entry+0x21&amp;gt;
 231:   5d                      pop    %rbp
 232:   48 81 ed 00 00 00 00    sub    $0x0,%rbp
 239:   48 01 2d 00 00 00 00    add    %rbp,0x0(%rip)        # 240 &amp;lt;efi_pe_entry+0x30&amp;gt;
 240:   48 89 c7                mov    %rax,%rdi
 243:   e8 00 00 00 00          callq  248 &amp;lt;efi_pe_entry+0x38&amp;gt;
 248:   48 83 f8 00             cmp    $0x0,%rax
 24c:   74 3f                   je     28d &amp;lt;fail&amp;gt;
 24e:   48 89 c6                mov    %rax,%rsi
 251:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 258 &amp;lt;efi_pe_entry+0x48&amp;gt;
 258:   89 86 14 02 00 00       mov    %eax,0x214(%rsi)
 25e:   eb 18                   jmp    278 &amp;lt;handover_entry+0x18&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;おまけ&quot;&gt;おまけ&lt;/h2&gt;

&lt;p&gt;参考までにEDK2でビルドしたHello WorldをUEFI Shell上で出力するEFI Applicationのhexdumpの結果を以下に示す．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000000: 4d5a 0000 0000 0000 0000 0000 0000 0000  MZ..............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 8000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 5045 0000 6486 0300 0000 0000 0000 0000  PE..d...........
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ここからわかるように，EFIではDOSヘッダについてはSignatureと0x3c位置の部分しか見ないようである．
そのため，先のbzImageではこの他の領域をLegacy Bootのために有効活用しているようである．&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://upload.wikimedia.org/wikipedia/commons/7/70/Portable_Executable_32_bit_Structure_in_SVG.svg&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">EFI環境においてLinux kernelの起動方法には ブートローダを用いる方法とEFI stubの2通りがある． EFI stubではbzImageに対してEFI Application相当のヘッダを付加することで EFIから直接kernelを起動する． ここでは，EFI stubなLinux kernelのヘッダが実際に見ることで どのように直接起動できるようにしているかを見ていく． 実際の記事を書いたのが相当前なので，ここではLinux kernel 4.5を対象としている．</summary></entry><entry><title type="html">BitVisorのEFI向け VMM Loader(1st stage)のコードを読んでみる</title><link href="http://localhost:4000/2017/12/07/bitvisor-efi-loader.html" rel="alternate" type="text/html" title="BitVisorのEFI向け VMM Loader(1st stage)のコードを読んでみる" /><published>2017-12-07T02:05:28+09:00</published><updated>2017-12-07T02:05:28+09:00</updated><id>http://localhost:4000/2017/12/07/bitvisor-efi-loader</id><content type="html" xml:base="http://localhost:4000/2017/12/07/bitvisor-efi-loader.html">&lt;p&gt;この記事は
&lt;a href=&quot;https://qiita.com/advent-calendar/2017/bitvisor&quot;&gt;BitVisor Advent Calendar&lt;/a&gt;
7日目の記事として書かれた．
ここでは，BitVisorのEFI向け VMMLoader(1st stage)のコードを読んでみる．&lt;/p&gt;

&lt;p&gt;EFI Loaderのコードは
&lt;a href=&quot;https://bitbucket.org/bitvisor/bitvisor/src/34fa14de2421cd3564323eec998f8e0c465e99a0/boot/uefi-loader/loadvmm.c?at=default&amp;amp;fileviewer=file-view-default&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;boot/uefi-loader/loadvmm.c&lt;/code&gt;&lt;/a&gt;
にある．&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;efi_main&lt;/code&gt;をみていく．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        status = systab-&amp;gt;BootServices-&amp;gt;
                HandleProtocol (image, &amp;amp;LoadedImageProtocol, &amp;amp;tmp);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;LoadedImageProtocolがサポートされているかを確認．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        status = systab-&amp;gt;BootServices-&amp;gt;
                HandleProtocol (loaded_image-&amp;gt;DeviceHandle,
                                &amp;amp;FileSystemProtocol, &amp;amp;tmp);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;FileSystemProtocolがサポートされているかを確認．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        create_file_path (loaded_image-&amp;gt;FilePath, L&quot;bitvisor.elf&quot;, file_path,
                          sizeof file_path / sizeof file_path[0]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ここで，&lt;code class=&quot;highlighter-rouge&quot;&gt;bitvisor.elf&lt;/code&gt;までのパスを作成する．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        status = fileio-&amp;gt;OpenVolume (fileio, &amp;amp;file);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ボリュームを開く．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        status = file-&amp;gt;Open (file, &amp;amp;file2, file_path, EFI_FILE_MODE_READ, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;先で作成したファイルパスのファイルを開く．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        status = systab-&amp;gt;BootServices-&amp;gt;AllocatePages (AllocateMaxAddress,
                                                      EfiLoaderData, 0x10,
                                                      &amp;amp;paddr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;4KiB*0x10=64KiBだけページをAllocateする．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	readsize = 0x10000;
	status = file2-&amp;gt;Read (file2, &amp;amp;readsize, (void *)paddr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bitvisor.elf&lt;/code&gt;のうち0x10000だけpaddrに展開する．
このあたりのマジックナンバーについては榮樂さんによる&lt;a href=&quot;https://www.bitvisor.org/summit2/slides/bitvisor-summit-2-03-eiraku.pdf&quot;&gt;スライド&lt;/a&gt;
に詳しく書いてある．
それによれば，&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BitVisorのVMMローダ(2nd stage)ではELFバイナリの先頭64KiB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(20ページ目)
とある．この部分はその先頭64KiBを読み出していると考えられる．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	entry = *(uint32_t *)(paddr + 0x18);
	entry_func = (entry_func_t *)(paddr + (entry &amp;amp; 0xFFFF));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ELFの先頭アドレスからエントリポイントを計算し，&lt;code class=&quot;highlighter-rouge&quot;&gt;entry_func&lt;/code&gt;とする．&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	struct bitvisor_boot boot_ext = {
		UEFI_BITVISOR_BOOT_UUID,
		paddr,
		readsize,
		file2
	};
	void *boot_exts[] = {
		&amp;amp;boot_ext,
		NULL
	};

	boot_error = entry_func (image, systab, boot_exts);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;必要な情報を構造体に抱えて&lt;code class=&quot;highlighter-rouge&quot;&gt;entry_func&lt;/code&gt;に飛び込む．&lt;/p&gt;

&lt;p&gt;以上を簡単にまとめると，
ファイルの読み出し-&amp;gt;エントリポイントの計算-&amp;gt;エントリポイントへのジャンプ
のようになっている．
ELFのパースを行わないことで，簡素な実装となっていることが見て取れる．
また，&lt;/p&gt;

&lt;h2 id=&quot;最後に&quot;&gt;最後に&lt;/h2&gt;

&lt;p&gt;EFIアプリケーションの開発と言えばEDK2やgnu-efiがあるが，
BitVisorのEFI Loaderの場合，EDKからのヘッダを利用し，
&lt;code class=&quot;highlighter-rouge&quot;&gt;x86_64-w64-mingw32-gcc&lt;/code&gt;によりコンパイルを行う．
このため依存関係が少なくコンパイルが容易であると言える．&lt;/p&gt;

&lt;p&gt;BitVisorの&lt;code class=&quot;highlighter-rouge&quot;&gt;uefi-loader&lt;/code&gt;に加え，品川先生の&lt;a href=&quot;https://github.com/utshina/uefi-simple&quot;&gt;uefi-simple&lt;/a&gt;に刺激を受け，
&lt;a href=&quot;https://github.com/retrage/uefi-sample&quot;&gt;uefi-sample&lt;/a&gt;
というサンプルを作成した．
これにより，EDK2やgnu-efiに頼ることなくEFIアプリケーションを作成することができる．&lt;/p&gt;

&lt;p&gt;ここでは，BitVisor のVMMローダ(1st stage)のコードを読んだ．
機会があれば，2nd stageのコードも読んでみたい．&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://bitbucket.org/bitvisor/bitvisor&lt;/li&gt;
  &lt;li&gt;https://www.bitvisor.org/summit2/slides/bitvisor-summit-2-03-eiraku.pdf&lt;/li&gt;
  &lt;li&gt;https://qiita.com/hdk_2/items/b73161f08fefce0d99c3&lt;/li&gt;
  &lt;li&gt;https://github.com/utshina/uefi-simple&lt;/li&gt;
  &lt;li&gt;https://github.com/retrage/uefi-sample&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">この記事は BitVisor Advent Calendar 7日目の記事として書かれた． ここでは，BitVisorのEFI向け VMMLoader(1st stage)のコードを読んでみる．</summary></entry><entry><title type="html">Windows 10にEZP2010のドライバをインストール</title><link href="http://localhost:4000/2017/11/09/windows10-ezp2010-driver.html" rel="alternate" type="text/html" title="Windows 10にEZP2010のドライバをインストール" /><published>2017-11-09T02:13:21+09:00</published><updated>2017-11-09T02:13:21+09:00</updated><id>http://localhost:4000/2017/11/09/windows10-ezp2010-driver</id><content type="html" xml:base="http://localhost:4000/2017/11/09/windows10-ezp2010-driver.html">&lt;p&gt;EZP2010はAmazonなどで安価に販売されているROMライタである．
すでに公式のWebサイトが閉鎖されていたりして
Windows 10のドライバは公式には配布されていない．
Windows 7でのインストール手順を記している方がいらっしゃるが[1]，
この方法ではうまく動かなかった．
非常に汚い方法ではあるがメモ程度にやり方をまとめておく．&lt;/p&gt;

&lt;p&gt;最初にEZP2010付属のCDからファイルを吸い出しておく．
Englishと中文の2つがあるがEnglishの方のディレクトリ構成は
以下のようになっている&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;english
    &lt;ul&gt;
      &lt;li&gt;document&lt;/li&gt;
      &lt;li&gt;setup&lt;/li&gt;
      &lt;li&gt;usbdriver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのうち，usbdriverがドライバになっているがこのままでは
インストールできない．
ドライバが署名されていないためである．&lt;/p&gt;

&lt;p&gt;そこで，
cmd.exeを管理者として起動，&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bcdedit /set testsigning on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;を実行し，マシンを再起動する[2]．
これによりテストモードとして起動するので，
ドライバの署名を必要としなくなるようである．&lt;/p&gt;

&lt;p&gt;次に
EZP2010をUSBでマシンに接続する．
「コンピュータの管理」から
「不明なデバイス」扱いになっているEZP2010を探し出す．
「ドライバの更新」でローカルにある
&lt;code class=&quot;highlighter-rouge&quot;&gt;usbdriver\win7_64bit&lt;/code&gt;
を指定してインストールする．&lt;/p&gt;

&lt;p&gt;最後に
&lt;code class=&quot;highlighter-rouge&quot;&gt;setup\EZP2010 V3.0\EZP2010 V3.0\EZP2010.exe&lt;/code&gt;
を起動して認識されていることを確認する．&lt;/p&gt;

&lt;p&gt;作業内容としては以上である．
[1]の方が指摘されているように，
このようなやり方はセキュリティ的に非常によろしくない．
色々と思うことはあるが，ここに書くのは蛇足な気がするので書かない，
できるだけメインで使うようなマシンでは行いたくない作業である．&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[1] http://www.minokasago.org/HobbyElectronicsWiki/index.php?EZP2010&lt;/li&gt;
  &lt;li&gt;[2] https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">EZP2010はAmazonなどで安価に販売されているROMライタである． すでに公式のWebサイトが閉鎖されていたりして Windows 10のドライバは公式には配布されていない． Windows 7でのインストール手順を記している方がいらっしゃるが[1]， この方法ではうまく動かなかった． 非常に汚い方法ではあるがメモ程度にやり方をまとめておく．</summary></entry><entry><title type="html">BitbucketとCircle CIでLatexする</title><link href="http://localhost:4000/2017/08/29/bitbucket-circleci.html" rel="alternate" type="text/html" title="BitbucketとCircle CIでLatexする" /><published>2017-08-29T11:10:58+09:00</published><updated>2017-08-29T11:10:58+09:00</updated><id>http://localhost:4000/2017/08/29/bitbucket-circleci</id><content type="html" xml:base="http://localhost:4000/2017/08/29/bitbucket-circleci.html">&lt;p&gt;前回からだいぶ空いてしまったが，小ネタを投下する．
以前に，
&lt;a href=&quot;http://retrage01.hateblo.jp/entry/2014/10/04/191435&quot;&gt;Jenkins+Bitbucket(Git)でLaTeX&lt;/a&gt;
という記事を書いた．
ここでは，CIを用いてlatexdiffによる差分Latexの生成，
コンパイル，Downloadsへのアップロード
を行うようなものを作ってみた．&lt;/p&gt;

&lt;p&gt;Bitbucketは現在，PiplinesというCIのサービスを提供しているが，
Circle CIと比較して，一ヶ月あたりの無料枠が小さいため，
ここではCircle CIを利用する．
なお，Circle CI 2.0を対象とする．&lt;/p&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/retrage/dc0980ec4c79b33cd522c4f4f4b82900#file-config-yml&quot;&gt;config.yml for Latex on Circle CI 2.0&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;既存のdockerイメージの利用&quot;&gt;既存のDockerイメージの利用&lt;/h2&gt;

&lt;p&gt;Latex環境構築，特に日本語文書を扱う場合，やや手続きが煩雑となるが，
Circle CIでは任意のDockerイメージが利用できる．
ここでは，
&lt;code class=&quot;highlighter-rouge&quot;&gt;paperist/alpine-texlive-ja&lt;/code&gt;
を使わせてもらった[1]．&lt;/p&gt;

&lt;h2 id=&quot;準備&quot;&gt;準備&lt;/h2&gt;

&lt;p&gt;先のDockerイメージは小さくて良いのだが，いくつかこの後必要となる
ものがないので，それらをインストールする．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apk add --update git patch curl
apk add --update ca-certificates openssl &amp;amp;&amp;amp; update-ca-certificates
tlmgr install ulem latexdiff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;latexmkを利用するために，&lt;code class=&quot;highlighter-rouge&quot;&gt;.latexmkrc&lt;/code&gt;を置いておく．
あまり良いやり方ではないが，
リポジトリに元となるファイルを含ませておく．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp .latexmkrc ~/.latexmkrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;latexファイルのコンパイル&quot;&gt;Latexファイルのコンパイル&lt;/h2&gt;

&lt;p&gt;普通にやる．後でartifactsをアップロードするため，
&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/artifacts&lt;/code&gt;にまとめておく．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;latexmk main.tex;
mkdir /tmp/artifacts;
cp main.pdf /tmp/artifacts/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;diffの作成とコンパイル&quot;&gt;diffの作成とコンパイル&lt;/h2&gt;

&lt;p&gt;これも普通にやる．日本語だと[2]
にあるような問題があるため，
パッチを当てる必要があったりする．
また，BibTeX周りもちゃんとやらなければならないのだが，
ここではやらない．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;latexdiff-vc -e utf8 --git -r HEAD^ -r HEAD main.tex;
latexmk main-diffHEAD^-HEAD.tex;
cp main-diffHEAD^-HEAD.pdf /tmp/artifacts/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bitbucketのdownloadsへのアップロード&quot;&gt;BitbucketのDownloadsへのアップロード&lt;/h2&gt;

&lt;p&gt;基本的には[3]の通り行う．Bitbucketで作成したApp Passwordを
Circle CI側にEnvironment Variableとして与えてやる．
以下のようにartifactsをcurlを使ってアップロードする．&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST &quot;https://${BB_AUTH_STRING}@api.bitbucket.org/2.0/repositories/${CIRCLE_PR    OJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/downloads&quot; --form files=@&quot;/tmp/artifacts/main.pdf&quot;;
 curl -X POST &quot;https://${BB_AUTH_STRING}@api.bitbucket.org/2.0/repositories/${CIRCLE_PR    OJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/downloads&quot; --form files=@&quot;/tmp/artifacts/main-diffHEAD^-HEAD.pdf&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ざっくり説明をしてみた．
Circle CI 2.0向けの資料は公式ドキュメントが揃っているとはいえ
まだそんなに多くない印象．
App Passwordだけは外に漏らさないようにしたい．&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[1] http://3846masa.hatenablog.jp/entry/2017/02/08/215920&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[2] http://quickhack.net/nom/blog/2013-06-16-latexdiff-for-japanese-documents.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[3] https://confluence.atlassian.com/bitbucket/deploy-build-artifacts-to-bitbucket-downloads-872124574.html&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">前回からだいぶ空いてしまったが，小ネタを投下する． 以前に， Jenkins+Bitbucket(Git)でLaTeX という記事を書いた． ここでは，CIを用いてlatexdiffによる差分Latexの生成， コンパイル，Downloadsへのアップロード を行うようなものを作ってみた．</summary></entry></feed>