<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>LKL.js: Running Linux Kernel on JavaScript Directly | めもちょー</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="LKL.js: Running Linux Kernel on JavaScript Directly" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I ported Linux kernel directly on JavaScript. In other words, I translated the Linux kernel to JavaScript using Emscripten, and Unlike JSLinux, it runs without emulators. The following is the working repository. https://github.com/retrage/linux/tree/retrage/em-v2 I published a demonstration site for LKL.js. Please enable SharedArrayBuffer and try it out LKL.js Demo I also published slides about LKL.js. https://speakerdeck.com/retrage/lkl-dot-js-running-linux-kernel-on-javascript-star-directly-star Linux Kernel Library (LKL) We use Linux Kernel Library (LKL) which makes the Linux kernel an anykernel. LKL is a fork of torvalds/linux. It is designed to put LKL specific code only in arch/lkl and runs without modifications of other code. By this design, it makes easy to follow the mainline. (Currently v4.16) Since LKL is anykernel, it runs on user space of various OS such as Linux, FreeBSD, and Windows etc. Emscripten Emscripten is LLVM based C/C++ to JavaScript/WebAssembly transpiler. It also provides a Unix-like environment to run translated software on web browsers. Can we port LKL to JavaScript with Emscripten? LKL runs on various OSes, Emscripten provides Unix-like environment. So can LKL be ported to JavaScript with Emscripten? Current Status of Linux Kernel Build with Clang First of all, the Linux kernel is deeply dependent on gcc-extension, and there is a doubt that Clang can not compile it. Once upon the time, there was LLVMLinux project that aims to compile Linux kernel with Clang. However, through the efforts of the Google Android team, two LTS (4.4 and 4.9) can be built with Clang. Now, LKL can be built with Clang. LKL Build Flow 101 Let’s look at the build flow of LKL. First, when $ make -C tools/lkl is performed, the build system determines which source code (*.c/*.S) to be built from the Kconfig settings and compiles them. Object files (*.o) generated by compiling are once archived by ar to built-in.o. Next, it links all built-in.o files into vmlinux at once. For host side code, files under tools/lkl/lib compiled and linked to liblkl.o. Finally, link all files (vmlinux and liblkl.o) to liblkl.so. This is a simple build flow of LKL. Porting LKL with Emscripten Next, we will take a look at how to port LKL with Emscripten. Not limited to Emscripten, when using LLVM infrastructures, the compiler compiles source to target with the following flow. Soruce -&gt; LLVM IR -&gt; Target In this way, the source is once converted to LLVM IR (*.bc/*.ll) and then converted to the target. In Emscripten, the “linking” is the conversion from LLVM IR to JavaScript. Therefore, it is necessary to first convert all (including libc etc. provided by Emscripten) to LLVM IR. Generating vmlinux.bc The build using emcc (An Emscripten Clang wrapper) is: make -C tools/lkl CC=&quot;$CC $CFLAGS&quot; AR=&quot;$PY $PWD/ar.py&quot; V=1 The two important things here are $FCFLAS and ar.py. I will explain each one. (Note that C=&quot;$CC $CFLAGS&quot; is forced to pass $CFLAGS) $CFLAGS is: CFLAGS=&quot;$CFLAGS -s WASM=0&quot; CFLAGS=&quot;$CFLAGS -s ASYNCIFY=1&quot; CFLAGS=&quot;$CFLAGS -s EMULATE_FUNCTION_POINTER_CASTS=1&quot; CFLAGS=&quot;$CFLAGS -s USE_PTHREADS=1&quot; CFLAGS=&quot;$CFLAGS -s PTHREAD_POOL_SIZE=4&quot; CFLAGS=&quot;$CFLAGS -s TOTAL_MEMORY=1342177280&quot; The options are to pass to Emscripten. Please refer to the Emscripten manual for details. Furthermore, the following definitions are specified. CFLAGS=&quot;$CFLAGS -DMAX_NR_ZONES=2&quot; CFLAGS=&quot;$CFLAGS -DNR_PAGEFLAGS=20&quot; CFLAGS=&quot;$CFLAGS -DSPINLOCK_SIZE=0&quot; CFLAGS=&quot;$CFLAGS -DF_GETLK64=12&quot; CFLAGS=&quot;$CFLAGS -DF_SETLK64=13&quot; CFLAGS=&quot;$CFLAGS -DF_SETLKW64=14&quot; These values are originally obtained by compiling an empty file at the time of Linux kernel build. However, this time they can not be obtained directly. Therefore, we have to specify these values which come from when building with the x86_64 environment. Next, I will explain ar.py. The following is a snippet of ar.py. filename = &quot;objs&quot; def main(): if not os.path.exists(filename): with open(filename, &quot;w&quot;) as fp: pass objs = [] for i, arg in enumerate(sys.argv): if &quot;.o&quot; in arg and not &quot;built-in&quot; in arg and i &gt; 2: objs.append(arg) with open(filename, &quot;aw&quot;) as fp: for obj in objs: if not obj is &quot;&quot;: fp.write(obj + &quot; &quot;) return 0 As explained above, the build system of Linux kernel gathers object files by ar and links them to get vmlinux. To work with Emscripten we need to get vmlinux as a LLVM bitcode. LLVM has a linker called llvm-link that links multiple LLVM bitcode files to get one LLVM bitcode. To generate vmlinux.bc, we need to use llvm-link, but there is a problem. llvm-link can not take archive files as arguments like lds. Therefore, we have to record object files that are originally archived. In this case, ar.py will record them as file paths in objs. Next, Let’s look at the part of vmlinux.bc generation. I added following scripts to scripts/link-vmlinux.sh. info CLEAN obj python &quot;${srctree}/clean-obj.py&quot; info GEN link-vmlinux.sh python &quot;${srctree}/link-vmlinux-gen.py&quot; info LINK vmlinux bash &quot;${srctree}/link-vmlinux.sh&quot; clean-obj.py removes duplicated file paths from objs which is generated by ar.py. link-vmlinux-gen.py generates vmlinux-link.sh (not scripts/link-vmlinux.sh) which performs llvm-link. By performing vmlinux-link.sh, we can get vmlinux.bc. This is the flow of generating vmlinux.bc. Generating boot.js Next, I will look at until JavaScript code is generated. As explained above, since LKL is one of Library OS, vmlinux does not work on its own, it works only when it has a part of an application. In this case, our target is tools/lkl/tests/boot which is LKL’s Hello, world. $LINK -o $LKL/tests/boot.bc \ $LKL/tests/boot-in.o $LKL/lib/liblkl-in.o $LKL/lib/lkl.o First, we have to link vmlinux.bc ($LKL/lib/lkl.o), host dependent part $LKL/lib/liblkl-in.o and applicatin part $LKL/tests/boot-in.o and get $LKL/tests/boot.bc. $DIS -o $LKL/tests/boot.ll $LKL/tests/boot.bc $CP ~/.emscripten_cache/asmjs/dlmalloc.bc js/dlmalloc.bc $CP ~/.emscripten_cache/asmjs/libc.bc js/libc.bc $CP ~/.emscripten_cache/asmjs/pthreads.bc js/pthreads.bc $DIS -o js/dlmalloc.ll js/dlmalloc.bc $DIS -o js/libc.ll js/libc.bc $DIS -o js/pthreads.ll js/pthreads.bc $PY rename_symbols.py $LKL/tests/boot.ll $LKL/tests/boot-mod.ll First, it disassembles all LLVM bitcode files ($LKL/tests/boot.bc and libc.bc etc.) using llvm-dis. Next, it applies rename_symbols.py to boot.ll. There is a reason for performing such operations. This is because function names used in the Linux kernel conflict with function names used in libcs. In normal LKL, this conflict is avoided by using ELF linker tricks. Meanwhile, since JavaScript generated by Emscripten does not have a namespace, such collisions occur. Therefore, by rewriting the functions names that would collide with rename_symbols.py, it can avoid collisions. In addition, rename_symbols.py also performs operations such as converting inline assemblies in Linux kernel to Emscripten emscripten_asm_const_int. From the boot-mod.ll, EMCC_DEBUG=1 $CC -o js/boot.html $LKL/tests/boot-mod.ll $CFLAGS -v generate HTML and JavaScript files. Adding Workarounds Although we generated the Linux kernel translated in “completely” JavaScript and the application boot.js, it will not work as it is. This is due to the fact that the architecture of computers and JavaScript is very different. So we have to make some modifications. Replacing inline assemblies In the Linux kernel, the architecture-dependent code is basically placed under arch/$ARCH, and other code are architecture independent. However, an empty inline assembly may be inserted so that optimization by the compiler prevents meaningful code from being lost at compile time. Here is an example, set_normalized_timespec64 in kernel/time/time.c: void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec) { while (nsec &gt;= NSEC_PER_SEC) { /* * The following asm() prevents the compiler from * optimising this loop into a modulo operation. See * also __iter_div_u64_rem() in include/linux/time.h */ asm(&quot;&quot; : &quot;+rm&quot;(nsec)); nsec -= NSEC_PER_SEC; ++sec; } while (nsec &lt; 0) { asm(&quot;&quot; : &quot;+rm&quot;(nsec)); nsec += NSEC_PER_SEC; --sec; } ts-&gt;tv_sec = sec; ts-&gt;tv_nsec = nsec; } Such Inline assemblies cause a failure to convert from LLVM bitcode to JavaScript. Therefore, we have to replace inline assemblies such as asm(&quot;&quot; : &quot;+rm&quot;(nsec)) with emcsripten_asm_const_int which calls JavaScript code from C defined in Emscripten. Fix early_param In the Linux kernel, there is early_param. This is defined in include/linux/init.h as follows: struct obs_kernel_param { const char *str; int (*setup_func)(char *); int early; }; /* snip */ #define __setup_param(str, unique_id, fn, early) \ static const char __setup_str_##unique_id[] __initconst \ __aligned(1) = str; \ static struct obs_kernel_param __setup_##unique_id \ __used __section(.init.setup) \ __attribute__((aligned((sizeof(long))))) \ = { __setup_str_##unique_id, fn, early } /* snip */ #define early_param(str, fn) \ __setup_param(str, fn, fn, 1) early_param is a macro, taking str and fn as arguments, and obs_kernel_param structure placed in .init.setup. By referring to arch/lkl/kernel/vmlinux.ldS which is generated in the build of LKL, we can see that .init.setup is arranged between __setup_start and __setup_end. __setup_start = .; KEEP(*(.init.setup)) __setup_end = .; These symbols will be used in init/main.c as follows. Here it compares one of boot parameter (param) of Linux kernel with str of obs_kernel_param in .init.setup. If it matches, it will execute (*setup_func)(char*) with argument val. /* Check for early params. */ static int __init do_early_param(char *param, char *val, const char *unused, void *arg) { const struct obs_kernel_param *p; for (p = __setup_start; p &lt; __setup_end; p++) { if ((p-&gt;early &amp;&amp; parameq(param, p-&gt;str)) || (strcmp(param, &quot;console&quot;) == 0 &amp;&amp; strcmp(p-&gt;str, &quot;earlycon&quot;) == 0) ) { if (p-&gt;setup_func(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); } } /* We accept everything at this stage. */ return 0; } In summary, do_early_param executes setup_func registered by early_param by referring boot parameters. However, since it uses ELF symbols, it does not work correctly in JavaScript. For this reason, the function which will be called here is hard coded. static int __init do_early_param(char *param, char *val, const char *unused, void *arg) { /* XXX: There is a lot of early_param, but hardcode in init/main.c */ const char *early_params[MAX_INIT_ARGS+2] = { &quot;debug&quot;, &quot;quiet&quot;, &quot;loglevel&quot;, NULL, }; int i; for (i = 0; early_params[i]; i++) { if (strcmp(param, early_params[i]) == 0 || (strcmp(param, &quot;console&quot;) == 0 &amp;&amp; strcmp(early_params[i], &quot;earlycon&quot;) == 0) ) { switch (i) { case 0: /* debug */ if (debug_kernel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); break; case 1: /* quiet */ if (quiet_kernel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); break; case 2: /* loglevel */ if (loglevel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); break; default: pr_warn(&quot;Unknown early option &#39;%s&#39;\n&quot;, param); } } } /* We accept everything at this stage. */ return 0; } Fix initcall Like early_param, initcall which are called in the initialization manages functions using ELF symbols. With JavaScript alone, we can not know which function should be called. Therefore, we have to generate inticall tables from System.map generated by a normal build of LKL. with open(sys.argv[1], &quot;r&quot;) as fp: for line in fp: if SIG in line: symbol = line[:-1].split(&quot; &quot;)[2] try: level = int(symbol[-1]) initcall = symbol[symbol.index(SIG)+len(SIG):len(symbol)-1] initcalls[level].append(initcall) except ValueError: pass for level, row in enumerate(initcalls): print(&quot;/* initcall{} */&quot;.format(level)) print(&quot;EM_ASM({&quot;) for initcall in row: if initcall in blacklist: print(&quot; /* _&quot;+initcall+&quot;(); */&quot;) else: print(&quot; _&quot;+initcall+&quot;();&quot;) print(&quot;});&quot;) The above is the initcall table generation script. We hard-code the code to do_initcalls. EM_ASM is an inline assembly that directly calls the JavaScript code in C. static void __init do_initcalls(void) { /* XXX: initcalls are broken, so hardcode here */ /* initcall0 */ EM_ASM({ _net_ns_init(); }); /* initcall1 */ EM_ASM({ _lkl_console_init(); _wq_sysfs_init(); _ksysfs_init(); /* snip */ }); } Demonstration and the Results As described at the top, LKL.js uses pthread, we have to enable SharedArrayBuffer. Although every modern web browsers are shipped with SharedarrayBuffer, it is disabled by default because of Spectre mitigation in Mozilla Firefox. Therefore, please enable it before executing the demo. The following is the result of start_kernel. We can see that it shows dmesg on browsers. [ 0.000000] Linux version 4.16.0+ (akira@akira-Z270) () #13 Tue Jul 17 23:01:19 JST 2018 [ 0.000000] bootmem address range: 0x675000 - 0x1674000 [ 0.000000] On node 0 totalpages: 4095 [ 0.000000] Normal zone: 36 pages used for memmap [ 0.000000] Normal zone: 0 pages reserved [ 0.000000] Normal zone: 4095 pages, LIFO batch:0 [ 0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768 [ 0.000000] pcpu-alloc: [0] 0 [ 0.000000] Built 1 zonelists, mobility grouping off. Total pages: 4059 [ 0.000000] Kernel command line: mem=16M loglevel=8 [ 0.000000] Parameter is obsolete, ignored [ 0.000000] Parameter is obsolete, ignored [ 0.000000] Dentry cache hash table entries: 2048 (order: 1, 8192 bytes) [ 0.000000] Inode-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.000000] Memory available: 16144k/16380k RAM [ 0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1 [ 0.000000] NR_IRQS: 1024 [ 0.000000] lkl: irqs initialized [ 0.000000] clocksource: lkl: mask: 0xffffffffffffffff max_cycles: 0x1cd42e4dffb, max_idle_ns: 881590591483 ns [ 0.000100] lkl: time and timers initialized (irq1) [ 0.001100] pid_max: default: 4096 minimum: 301 [ 0.009400] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.009900] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.327100] console [lkl_console0] enabled [ 0.329600] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.329700] xor: automatically using best checksumming function 8regs [ 0.341199] NET: Registered protocol family 16 [ 0.388999] clocksource: Switched to clocksource lkl [ 0.414100] NET: Registered protocol family 2 [ 0.437700] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes) [ 0.438199] TCP established hash table entries: 1024 (order: 0, 4096 bytes) [ 0.439000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes) [ 0.439600] TCP: Hash tables configured (established 1024 bind 1024) [ 0.443200] UDP hash table entries: 256 (order: 0, 4096 bytes) [ 0.444000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes) [ 0.472100] workingset: timestamp_bits=30 max_order=12 bucket_order=0 [ 0.863100] SGI XFS with ACLs, security attributes, no debug enabled [ 0.923700] jitterentropy: Initialization failed with host not compliant with requirements: 2 [ 0.924599] io scheduler noop registered [ 0.924900] io scheduler deadline registered [ 0.933099] io scheduler cfq registered (default) [ 0.933500] io scheduler kyber registered [ 1.633500] NET: Registered protocol family 10 [ 1.658400] Segment Routing with IPv6 [ 1.660800] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver [ 1.674200] ------------[ cut here ]------------ [ 1.675500] WARNING: CPU: 0 PID: 0 at arch/lkl/kernel/setup.c:188 (null) [ 1.675899] Call Trace: [ 1.676200] [ 1.676999] ---[ end trace 941dc55fe0966cff ]--- [ 1.684299] Warning: unable to open an initial console. [ 1.685200] This architecture does not have kernel memory protection. pthread_join((pthread_t)tid, NULL): No such process lkl_start_kernel(&amp;lkl_host_ops, &quot;mem=16M loglevel=8&quot;) = 0 Limitations From the above results, we confirmed that Linux kernel was booted directly in JavaScript. However, it just outputted dmesg and it is not suitable for practical use at all. This is because of the following problems: It fails to create kernel threads. It fails to mount rootfs. It fails to execute init (PID 1). Also, support for pthreads in Emscripten is not good. We extracted semaphore, mutex, and thread from Little Kernel (LK) and add them to LKL as green threads. https://github.com/retrage/linux/tree/retrage/fiber We plan to create LKL.js using this green threads. Summary We created a Linux kernel fully translated in JavaScript using LKL and Emscripten. It boots the Linux kernel and we confirmed that it shows dmesg. Although the architecture is greatly different between computers and JavaScript, we found that it works somewhat by adding some fixes and workarounds. Reference https://github.com/lkl/linux https://github.com/kripken/emscripten https://llvm.org/ https://clang.llvm.org/ https://wiki.linuxfoundation.org/llvmlinux https://lwn.net/Articles/734071/ http://llvm.org/docs/CommandGuide/llvm-link.html https://0xax.gitbooks.io/linux-insides/Concepts/linux-cpu-3.html https://github.com/littlekernel/lk" />
<meta property="og:description" content="I ported Linux kernel directly on JavaScript. In other words, I translated the Linux kernel to JavaScript using Emscripten, and Unlike JSLinux, it runs without emulators. The following is the working repository. https://github.com/retrage/linux/tree/retrage/em-v2 I published a demonstration site for LKL.js. Please enable SharedArrayBuffer and try it out LKL.js Demo I also published slides about LKL.js. https://speakerdeck.com/retrage/lkl-dot-js-running-linux-kernel-on-javascript-star-directly-star Linux Kernel Library (LKL) We use Linux Kernel Library (LKL) which makes the Linux kernel an anykernel. LKL is a fork of torvalds/linux. It is designed to put LKL specific code only in arch/lkl and runs without modifications of other code. By this design, it makes easy to follow the mainline. (Currently v4.16) Since LKL is anykernel, it runs on user space of various OS such as Linux, FreeBSD, and Windows etc. Emscripten Emscripten is LLVM based C/C++ to JavaScript/WebAssembly transpiler. It also provides a Unix-like environment to run translated software on web browsers. Can we port LKL to JavaScript with Emscripten? LKL runs on various OSes, Emscripten provides Unix-like environment. So can LKL be ported to JavaScript with Emscripten? Current Status of Linux Kernel Build with Clang First of all, the Linux kernel is deeply dependent on gcc-extension, and there is a doubt that Clang can not compile it. Once upon the time, there was LLVMLinux project that aims to compile Linux kernel with Clang. However, through the efforts of the Google Android team, two LTS (4.4 and 4.9) can be built with Clang. Now, LKL can be built with Clang. LKL Build Flow 101 Let’s look at the build flow of LKL. First, when $ make -C tools/lkl is performed, the build system determines which source code (*.c/*.S) to be built from the Kconfig settings and compiles them. Object files (*.o) generated by compiling are once archived by ar to built-in.o. Next, it links all built-in.o files into vmlinux at once. For host side code, files under tools/lkl/lib compiled and linked to liblkl.o. Finally, link all files (vmlinux and liblkl.o) to liblkl.so. This is a simple build flow of LKL. Porting LKL with Emscripten Next, we will take a look at how to port LKL with Emscripten. Not limited to Emscripten, when using LLVM infrastructures, the compiler compiles source to target with the following flow. Soruce -&gt; LLVM IR -&gt; Target In this way, the source is once converted to LLVM IR (*.bc/*.ll) and then converted to the target. In Emscripten, the “linking” is the conversion from LLVM IR to JavaScript. Therefore, it is necessary to first convert all (including libc etc. provided by Emscripten) to LLVM IR. Generating vmlinux.bc The build using emcc (An Emscripten Clang wrapper) is: make -C tools/lkl CC=&quot;$CC $CFLAGS&quot; AR=&quot;$PY $PWD/ar.py&quot; V=1 The two important things here are $FCFLAS and ar.py. I will explain each one. (Note that C=&quot;$CC $CFLAGS&quot; is forced to pass $CFLAGS) $CFLAGS is: CFLAGS=&quot;$CFLAGS -s WASM=0&quot; CFLAGS=&quot;$CFLAGS -s ASYNCIFY=1&quot; CFLAGS=&quot;$CFLAGS -s EMULATE_FUNCTION_POINTER_CASTS=1&quot; CFLAGS=&quot;$CFLAGS -s USE_PTHREADS=1&quot; CFLAGS=&quot;$CFLAGS -s PTHREAD_POOL_SIZE=4&quot; CFLAGS=&quot;$CFLAGS -s TOTAL_MEMORY=1342177280&quot; The options are to pass to Emscripten. Please refer to the Emscripten manual for details. Furthermore, the following definitions are specified. CFLAGS=&quot;$CFLAGS -DMAX_NR_ZONES=2&quot; CFLAGS=&quot;$CFLAGS -DNR_PAGEFLAGS=20&quot; CFLAGS=&quot;$CFLAGS -DSPINLOCK_SIZE=0&quot; CFLAGS=&quot;$CFLAGS -DF_GETLK64=12&quot; CFLAGS=&quot;$CFLAGS -DF_SETLK64=13&quot; CFLAGS=&quot;$CFLAGS -DF_SETLKW64=14&quot; These values are originally obtained by compiling an empty file at the time of Linux kernel build. However, this time they can not be obtained directly. Therefore, we have to specify these values which come from when building with the x86_64 environment. Next, I will explain ar.py. The following is a snippet of ar.py. filename = &quot;objs&quot; def main(): if not os.path.exists(filename): with open(filename, &quot;w&quot;) as fp: pass objs = [] for i, arg in enumerate(sys.argv): if &quot;.o&quot; in arg and not &quot;built-in&quot; in arg and i &gt; 2: objs.append(arg) with open(filename, &quot;aw&quot;) as fp: for obj in objs: if not obj is &quot;&quot;: fp.write(obj + &quot; &quot;) return 0 As explained above, the build system of Linux kernel gathers object files by ar and links them to get vmlinux. To work with Emscripten we need to get vmlinux as a LLVM bitcode. LLVM has a linker called llvm-link that links multiple LLVM bitcode files to get one LLVM bitcode. To generate vmlinux.bc, we need to use llvm-link, but there is a problem. llvm-link can not take archive files as arguments like lds. Therefore, we have to record object files that are originally archived. In this case, ar.py will record them as file paths in objs. Next, Let’s look at the part of vmlinux.bc generation. I added following scripts to scripts/link-vmlinux.sh. info CLEAN obj python &quot;${srctree}/clean-obj.py&quot; info GEN link-vmlinux.sh python &quot;${srctree}/link-vmlinux-gen.py&quot; info LINK vmlinux bash &quot;${srctree}/link-vmlinux.sh&quot; clean-obj.py removes duplicated file paths from objs which is generated by ar.py. link-vmlinux-gen.py generates vmlinux-link.sh (not scripts/link-vmlinux.sh) which performs llvm-link. By performing vmlinux-link.sh, we can get vmlinux.bc. This is the flow of generating vmlinux.bc. Generating boot.js Next, I will look at until JavaScript code is generated. As explained above, since LKL is one of Library OS, vmlinux does not work on its own, it works only when it has a part of an application. In this case, our target is tools/lkl/tests/boot which is LKL’s Hello, world. $LINK -o $LKL/tests/boot.bc \ $LKL/tests/boot-in.o $LKL/lib/liblkl-in.o $LKL/lib/lkl.o First, we have to link vmlinux.bc ($LKL/lib/lkl.o), host dependent part $LKL/lib/liblkl-in.o and applicatin part $LKL/tests/boot-in.o and get $LKL/tests/boot.bc. $DIS -o $LKL/tests/boot.ll $LKL/tests/boot.bc $CP ~/.emscripten_cache/asmjs/dlmalloc.bc js/dlmalloc.bc $CP ~/.emscripten_cache/asmjs/libc.bc js/libc.bc $CP ~/.emscripten_cache/asmjs/pthreads.bc js/pthreads.bc $DIS -o js/dlmalloc.ll js/dlmalloc.bc $DIS -o js/libc.ll js/libc.bc $DIS -o js/pthreads.ll js/pthreads.bc $PY rename_symbols.py $LKL/tests/boot.ll $LKL/tests/boot-mod.ll First, it disassembles all LLVM bitcode files ($LKL/tests/boot.bc and libc.bc etc.) using llvm-dis. Next, it applies rename_symbols.py to boot.ll. There is a reason for performing such operations. This is because function names used in the Linux kernel conflict with function names used in libcs. In normal LKL, this conflict is avoided by using ELF linker tricks. Meanwhile, since JavaScript generated by Emscripten does not have a namespace, such collisions occur. Therefore, by rewriting the functions names that would collide with rename_symbols.py, it can avoid collisions. In addition, rename_symbols.py also performs operations such as converting inline assemblies in Linux kernel to Emscripten emscripten_asm_const_int. From the boot-mod.ll, EMCC_DEBUG=1 $CC -o js/boot.html $LKL/tests/boot-mod.ll $CFLAGS -v generate HTML and JavaScript files. Adding Workarounds Although we generated the Linux kernel translated in “completely” JavaScript and the application boot.js, it will not work as it is. This is due to the fact that the architecture of computers and JavaScript is very different. So we have to make some modifications. Replacing inline assemblies In the Linux kernel, the architecture-dependent code is basically placed under arch/$ARCH, and other code are architecture independent. However, an empty inline assembly may be inserted so that optimization by the compiler prevents meaningful code from being lost at compile time. Here is an example, set_normalized_timespec64 in kernel/time/time.c: void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec) { while (nsec &gt;= NSEC_PER_SEC) { /* * The following asm() prevents the compiler from * optimising this loop into a modulo operation. See * also __iter_div_u64_rem() in include/linux/time.h */ asm(&quot;&quot; : &quot;+rm&quot;(nsec)); nsec -= NSEC_PER_SEC; ++sec; } while (nsec &lt; 0) { asm(&quot;&quot; : &quot;+rm&quot;(nsec)); nsec += NSEC_PER_SEC; --sec; } ts-&gt;tv_sec = sec; ts-&gt;tv_nsec = nsec; } Such Inline assemblies cause a failure to convert from LLVM bitcode to JavaScript. Therefore, we have to replace inline assemblies such as asm(&quot;&quot; : &quot;+rm&quot;(nsec)) with emcsripten_asm_const_int which calls JavaScript code from C defined in Emscripten. Fix early_param In the Linux kernel, there is early_param. This is defined in include/linux/init.h as follows: struct obs_kernel_param { const char *str; int (*setup_func)(char *); int early; }; /* snip */ #define __setup_param(str, unique_id, fn, early) \ static const char __setup_str_##unique_id[] __initconst \ __aligned(1) = str; \ static struct obs_kernel_param __setup_##unique_id \ __used __section(.init.setup) \ __attribute__((aligned((sizeof(long))))) \ = { __setup_str_##unique_id, fn, early } /* snip */ #define early_param(str, fn) \ __setup_param(str, fn, fn, 1) early_param is a macro, taking str and fn as arguments, and obs_kernel_param structure placed in .init.setup. By referring to arch/lkl/kernel/vmlinux.ldS which is generated in the build of LKL, we can see that .init.setup is arranged between __setup_start and __setup_end. __setup_start = .; KEEP(*(.init.setup)) __setup_end = .; These symbols will be used in init/main.c as follows. Here it compares one of boot parameter (param) of Linux kernel with str of obs_kernel_param in .init.setup. If it matches, it will execute (*setup_func)(char*) with argument val. /* Check for early params. */ static int __init do_early_param(char *param, char *val, const char *unused, void *arg) { const struct obs_kernel_param *p; for (p = __setup_start; p &lt; __setup_end; p++) { if ((p-&gt;early &amp;&amp; parameq(param, p-&gt;str)) || (strcmp(param, &quot;console&quot;) == 0 &amp;&amp; strcmp(p-&gt;str, &quot;earlycon&quot;) == 0) ) { if (p-&gt;setup_func(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); } } /* We accept everything at this stage. */ return 0; } In summary, do_early_param executes setup_func registered by early_param by referring boot parameters. However, since it uses ELF symbols, it does not work correctly in JavaScript. For this reason, the function which will be called here is hard coded. static int __init do_early_param(char *param, char *val, const char *unused, void *arg) { /* XXX: There is a lot of early_param, but hardcode in init/main.c */ const char *early_params[MAX_INIT_ARGS+2] = { &quot;debug&quot;, &quot;quiet&quot;, &quot;loglevel&quot;, NULL, }; int i; for (i = 0; early_params[i]; i++) { if (strcmp(param, early_params[i]) == 0 || (strcmp(param, &quot;console&quot;) == 0 &amp;&amp; strcmp(early_params[i], &quot;earlycon&quot;) == 0) ) { switch (i) { case 0: /* debug */ if (debug_kernel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); break; case 1: /* quiet */ if (quiet_kernel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); break; case 2: /* loglevel */ if (loglevel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\n&quot;, param); break; default: pr_warn(&quot;Unknown early option &#39;%s&#39;\n&quot;, param); } } } /* We accept everything at this stage. */ return 0; } Fix initcall Like early_param, initcall which are called in the initialization manages functions using ELF symbols. With JavaScript alone, we can not know which function should be called. Therefore, we have to generate inticall tables from System.map generated by a normal build of LKL. with open(sys.argv[1], &quot;r&quot;) as fp: for line in fp: if SIG in line: symbol = line[:-1].split(&quot; &quot;)[2] try: level = int(symbol[-1]) initcall = symbol[symbol.index(SIG)+len(SIG):len(symbol)-1] initcalls[level].append(initcall) except ValueError: pass for level, row in enumerate(initcalls): print(&quot;/* initcall{} */&quot;.format(level)) print(&quot;EM_ASM({&quot;) for initcall in row: if initcall in blacklist: print(&quot; /* _&quot;+initcall+&quot;(); */&quot;) else: print(&quot; _&quot;+initcall+&quot;();&quot;) print(&quot;});&quot;) The above is the initcall table generation script. We hard-code the code to do_initcalls. EM_ASM is an inline assembly that directly calls the JavaScript code in C. static void __init do_initcalls(void) { /* XXX: initcalls are broken, so hardcode here */ /* initcall0 */ EM_ASM({ _net_ns_init(); }); /* initcall1 */ EM_ASM({ _lkl_console_init(); _wq_sysfs_init(); _ksysfs_init(); /* snip */ }); } Demonstration and the Results As described at the top, LKL.js uses pthread, we have to enable SharedArrayBuffer. Although every modern web browsers are shipped with SharedarrayBuffer, it is disabled by default because of Spectre mitigation in Mozilla Firefox. Therefore, please enable it before executing the demo. The following is the result of start_kernel. We can see that it shows dmesg on browsers. [ 0.000000] Linux version 4.16.0+ (akira@akira-Z270) () #13 Tue Jul 17 23:01:19 JST 2018 [ 0.000000] bootmem address range: 0x675000 - 0x1674000 [ 0.000000] On node 0 totalpages: 4095 [ 0.000000] Normal zone: 36 pages used for memmap [ 0.000000] Normal zone: 0 pages reserved [ 0.000000] Normal zone: 4095 pages, LIFO batch:0 [ 0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768 [ 0.000000] pcpu-alloc: [0] 0 [ 0.000000] Built 1 zonelists, mobility grouping off. Total pages: 4059 [ 0.000000] Kernel command line: mem=16M loglevel=8 [ 0.000000] Parameter is obsolete, ignored [ 0.000000] Parameter is obsolete, ignored [ 0.000000] Dentry cache hash table entries: 2048 (order: 1, 8192 bytes) [ 0.000000] Inode-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.000000] Memory available: 16144k/16380k RAM [ 0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1 [ 0.000000] NR_IRQS: 1024 [ 0.000000] lkl: irqs initialized [ 0.000000] clocksource: lkl: mask: 0xffffffffffffffff max_cycles: 0x1cd42e4dffb, max_idle_ns: 881590591483 ns [ 0.000100] lkl: time and timers initialized (irq1) [ 0.001100] pid_max: default: 4096 minimum: 301 [ 0.009400] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.009900] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.327100] console [lkl_console0] enabled [ 0.329600] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.329700] xor: automatically using best checksumming function 8regs [ 0.341199] NET: Registered protocol family 16 [ 0.388999] clocksource: Switched to clocksource lkl [ 0.414100] NET: Registered protocol family 2 [ 0.437700] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes) [ 0.438199] TCP established hash table entries: 1024 (order: 0, 4096 bytes) [ 0.439000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes) [ 0.439600] TCP: Hash tables configured (established 1024 bind 1024) [ 0.443200] UDP hash table entries: 256 (order: 0, 4096 bytes) [ 0.444000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes) [ 0.472100] workingset: timestamp_bits=30 max_order=12 bucket_order=0 [ 0.863100] SGI XFS with ACLs, security attributes, no debug enabled [ 0.923700] jitterentropy: Initialization failed with host not compliant with requirements: 2 [ 0.924599] io scheduler noop registered [ 0.924900] io scheduler deadline registered [ 0.933099] io scheduler cfq registered (default) [ 0.933500] io scheduler kyber registered [ 1.633500] NET: Registered protocol family 10 [ 1.658400] Segment Routing with IPv6 [ 1.660800] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver [ 1.674200] ------------[ cut here ]------------ [ 1.675500] WARNING: CPU: 0 PID: 0 at arch/lkl/kernel/setup.c:188 (null) [ 1.675899] Call Trace: [ 1.676200] [ 1.676999] ---[ end trace 941dc55fe0966cff ]--- [ 1.684299] Warning: unable to open an initial console. [ 1.685200] This architecture does not have kernel memory protection. pthread_join((pthread_t)tid, NULL): No such process lkl_start_kernel(&amp;lkl_host_ops, &quot;mem=16M loglevel=8&quot;) = 0 Limitations From the above results, we confirmed that Linux kernel was booted directly in JavaScript. However, it just outputted dmesg and it is not suitable for practical use at all. This is because of the following problems: It fails to create kernel threads. It fails to mount rootfs. It fails to execute init (PID 1). Also, support for pthreads in Emscripten is not good. We extracted semaphore, mutex, and thread from Little Kernel (LK) and add them to LKL as green threads. https://github.com/retrage/linux/tree/retrage/fiber We plan to create LKL.js using this green threads. Summary We created a Linux kernel fully translated in JavaScript using LKL and Emscripten. It boots the Linux kernel and we confirmed that it shows dmesg. Although the architecture is greatly different between computers and JavaScript, we found that it works somewhat by adding some fixes and workarounds. Reference https://github.com/lkl/linux https://github.com/kripken/emscripten https://llvm.org/ https://clang.llvm.org/ https://wiki.linuxfoundation.org/llvmlinux https://lwn.net/Articles/734071/ http://llvm.org/docs/CommandGuide/llvm-link.html https://0xax.gitbooks.io/linux-insides/Concepts/linux-cpu-3.html https://github.com/littlekernel/lk" />
<link rel="canonical" href="http://localhost:4000/2018/07/25/lkl-js-en.html" />
<meta property="og:url" content="http://localhost:4000/2018/07/25/lkl-js-en.html" />
<meta property="og:site_name" content="めもちょー" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-25T20:29:00+09:00" />
<script type="application/ld+json">
{"headline":"LKL.js: Running Linux Kernel on JavaScript Directly","dateModified":"2018-07-25T20:29:00+09:00","url":"http://localhost:4000/2018/07/25/lkl-js-en.html","datePublished":"2018-07-25T20:29:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/07/25/lkl-js-en.html"},"description":"I ported Linux kernel directly on JavaScript. In other words, I translated the Linux kernel to JavaScript using Emscripten, and Unlike JSLinux, it runs without emulators. The following is the working repository. https://github.com/retrage/linux/tree/retrage/em-v2 I published a demonstration site for LKL.js. Please enable SharedArrayBuffer and try it out LKL.js Demo I also published slides about LKL.js. https://speakerdeck.com/retrage/lkl-dot-js-running-linux-kernel-on-javascript-star-directly-star Linux Kernel Library (LKL) We use Linux Kernel Library (LKL) which makes the Linux kernel an anykernel. LKL is a fork of torvalds/linux. It is designed to put LKL specific code only in arch/lkl and runs without modifications of other code. By this design, it makes easy to follow the mainline. (Currently v4.16) Since LKL is anykernel, it runs on user space of various OS such as Linux, FreeBSD, and Windows etc. Emscripten Emscripten is LLVM based C/C++ to JavaScript/WebAssembly transpiler. It also provides a Unix-like environment to run translated software on web browsers. Can we port LKL to JavaScript with Emscripten? LKL runs on various OSes, Emscripten provides Unix-like environment. So can LKL be ported to JavaScript with Emscripten? Current Status of Linux Kernel Build with Clang First of all, the Linux kernel is deeply dependent on gcc-extension, and there is a doubt that Clang can not compile it. Once upon the time, there was LLVMLinux project that aims to compile Linux kernel with Clang. However, through the efforts of the Google Android team, two LTS (4.4 and 4.9) can be built with Clang. Now, LKL can be built with Clang. LKL Build Flow 101 Let’s look at the build flow of LKL. First, when $ make -C tools/lkl is performed, the build system determines which source code (*.c/*.S) to be built from the Kconfig settings and compiles them. Object files (*.o) generated by compiling are once archived by ar to built-in.o. Next, it links all built-in.o files into vmlinux at once. For host side code, files under tools/lkl/lib compiled and linked to liblkl.o. Finally, link all files (vmlinux and liblkl.o) to liblkl.so. This is a simple build flow of LKL. Porting LKL with Emscripten Next, we will take a look at how to port LKL with Emscripten. Not limited to Emscripten, when using LLVM infrastructures, the compiler compiles source to target with the following flow. Soruce -&gt; LLVM IR -&gt; Target In this way, the source is once converted to LLVM IR (*.bc/*.ll) and then converted to the target. In Emscripten, the “linking” is the conversion from LLVM IR to JavaScript. Therefore, it is necessary to first convert all (including libc etc. provided by Emscripten) to LLVM IR. Generating vmlinux.bc The build using emcc (An Emscripten Clang wrapper) is: make -C tools/lkl CC=&quot;$CC $CFLAGS&quot; AR=&quot;$PY $PWD/ar.py&quot; V=1 The two important things here are $FCFLAS and ar.py. I will explain each one. (Note that C=&quot;$CC $CFLAGS&quot; is forced to pass $CFLAGS) $CFLAGS is: CFLAGS=&quot;$CFLAGS -s WASM=0&quot; CFLAGS=&quot;$CFLAGS -s ASYNCIFY=1&quot; CFLAGS=&quot;$CFLAGS -s EMULATE_FUNCTION_POINTER_CASTS=1&quot; CFLAGS=&quot;$CFLAGS -s USE_PTHREADS=1&quot; CFLAGS=&quot;$CFLAGS -s PTHREAD_POOL_SIZE=4&quot; CFLAGS=&quot;$CFLAGS -s TOTAL_MEMORY=1342177280&quot; The options are to pass to Emscripten. Please refer to the Emscripten manual for details. Furthermore, the following definitions are specified. CFLAGS=&quot;$CFLAGS -DMAX_NR_ZONES=2&quot; CFLAGS=&quot;$CFLAGS -DNR_PAGEFLAGS=20&quot; CFLAGS=&quot;$CFLAGS -DSPINLOCK_SIZE=0&quot; CFLAGS=&quot;$CFLAGS -DF_GETLK64=12&quot; CFLAGS=&quot;$CFLAGS -DF_SETLK64=13&quot; CFLAGS=&quot;$CFLAGS -DF_SETLKW64=14&quot; These values are originally obtained by compiling an empty file at the time of Linux kernel build. However, this time they can not be obtained directly. Therefore, we have to specify these values which come from when building with the x86_64 environment. Next, I will explain ar.py. The following is a snippet of ar.py. filename = &quot;objs&quot; def main(): if not os.path.exists(filename): with open(filename, &quot;w&quot;) as fp: pass objs = [] for i, arg in enumerate(sys.argv): if &quot;.o&quot; in arg and not &quot;built-in&quot; in arg and i &gt; 2: objs.append(arg) with open(filename, &quot;aw&quot;) as fp: for obj in objs: if not obj is &quot;&quot;: fp.write(obj + &quot; &quot;) return 0 As explained above, the build system of Linux kernel gathers object files by ar and links them to get vmlinux. To work with Emscripten we need to get vmlinux as a LLVM bitcode. LLVM has a linker called llvm-link that links multiple LLVM bitcode files to get one LLVM bitcode. To generate vmlinux.bc, we need to use llvm-link, but there is a problem. llvm-link can not take archive files as arguments like lds. Therefore, we have to record object files that are originally archived. In this case, ar.py will record them as file paths in objs. Next, Let’s look at the part of vmlinux.bc generation. I added following scripts to scripts/link-vmlinux.sh. info CLEAN obj python &quot;${srctree}/clean-obj.py&quot; info GEN link-vmlinux.sh python &quot;${srctree}/link-vmlinux-gen.py&quot; info LINK vmlinux bash &quot;${srctree}/link-vmlinux.sh&quot; clean-obj.py removes duplicated file paths from objs which is generated by ar.py. link-vmlinux-gen.py generates vmlinux-link.sh (not scripts/link-vmlinux.sh) which performs llvm-link. By performing vmlinux-link.sh, we can get vmlinux.bc. This is the flow of generating vmlinux.bc. Generating boot.js Next, I will look at until JavaScript code is generated. As explained above, since LKL is one of Library OS, vmlinux does not work on its own, it works only when it has a part of an application. In this case, our target is tools/lkl/tests/boot which is LKL’s Hello, world. $LINK -o $LKL/tests/boot.bc \\ $LKL/tests/boot-in.o $LKL/lib/liblkl-in.o $LKL/lib/lkl.o First, we have to link vmlinux.bc ($LKL/lib/lkl.o), host dependent part $LKL/lib/liblkl-in.o and applicatin part $LKL/tests/boot-in.o and get $LKL/tests/boot.bc. $DIS -o $LKL/tests/boot.ll $LKL/tests/boot.bc $CP ~/.emscripten_cache/asmjs/dlmalloc.bc js/dlmalloc.bc $CP ~/.emscripten_cache/asmjs/libc.bc js/libc.bc $CP ~/.emscripten_cache/asmjs/pthreads.bc js/pthreads.bc $DIS -o js/dlmalloc.ll js/dlmalloc.bc $DIS -o js/libc.ll js/libc.bc $DIS -o js/pthreads.ll js/pthreads.bc $PY rename_symbols.py $LKL/tests/boot.ll $LKL/tests/boot-mod.ll First, it disassembles all LLVM bitcode files ($LKL/tests/boot.bc and libc.bc etc.) using llvm-dis. Next, it applies rename_symbols.py to boot.ll. There is a reason for performing such operations. This is because function names used in the Linux kernel conflict with function names used in libcs. In normal LKL, this conflict is avoided by using ELF linker tricks. Meanwhile, since JavaScript generated by Emscripten does not have a namespace, such collisions occur. Therefore, by rewriting the functions names that would collide with rename_symbols.py, it can avoid collisions. In addition, rename_symbols.py also performs operations such as converting inline assemblies in Linux kernel to Emscripten emscripten_asm_const_int. From the boot-mod.ll, EMCC_DEBUG=1 $CC -o js/boot.html $LKL/tests/boot-mod.ll $CFLAGS -v generate HTML and JavaScript files. Adding Workarounds Although we generated the Linux kernel translated in “completely” JavaScript and the application boot.js, it will not work as it is. This is due to the fact that the architecture of computers and JavaScript is very different. So we have to make some modifications. Replacing inline assemblies In the Linux kernel, the architecture-dependent code is basically placed under arch/$ARCH, and other code are architecture independent. However, an empty inline assembly may be inserted so that optimization by the compiler prevents meaningful code from being lost at compile time. Here is an example, set_normalized_timespec64 in kernel/time/time.c: void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec) { while (nsec &gt;= NSEC_PER_SEC) { /* * The following asm() prevents the compiler from * optimising this loop into a modulo operation. See * also __iter_div_u64_rem() in include/linux/time.h */ asm(&quot;&quot; : &quot;+rm&quot;(nsec)); nsec -= NSEC_PER_SEC; ++sec; } while (nsec &lt; 0) { asm(&quot;&quot; : &quot;+rm&quot;(nsec)); nsec += NSEC_PER_SEC; --sec; } ts-&gt;tv_sec = sec; ts-&gt;tv_nsec = nsec; } Such Inline assemblies cause a failure to convert from LLVM bitcode to JavaScript. Therefore, we have to replace inline assemblies such as asm(&quot;&quot; : &quot;+rm&quot;(nsec)) with emcsripten_asm_const_int which calls JavaScript code from C defined in Emscripten. Fix early_param In the Linux kernel, there is early_param. This is defined in include/linux/init.h as follows: struct obs_kernel_param { const char *str; int (*setup_func)(char *); int early; }; /* snip */ #define __setup_param(str, unique_id, fn, early) \\ static const char __setup_str_##unique_id[] __initconst \\ __aligned(1) = str; \\ static struct obs_kernel_param __setup_##unique_id \\ __used __section(.init.setup) \\ __attribute__((aligned((sizeof(long))))) \\ = { __setup_str_##unique_id, fn, early } /* snip */ #define early_param(str, fn) \\ __setup_param(str, fn, fn, 1) early_param is a macro, taking str and fn as arguments, and obs_kernel_param structure placed in .init.setup. By referring to arch/lkl/kernel/vmlinux.ldS which is generated in the build of LKL, we can see that .init.setup is arranged between __setup_start and __setup_end. __setup_start = .; KEEP(*(.init.setup)) __setup_end = .; These symbols will be used in init/main.c as follows. Here it compares one of boot parameter (param) of Linux kernel with str of obs_kernel_param in .init.setup. If it matches, it will execute (*setup_func)(char*) with argument val. /* Check for early params. */ static int __init do_early_param(char *param, char *val, const char *unused, void *arg) { const struct obs_kernel_param *p; for (p = __setup_start; p &lt; __setup_end; p++) { if ((p-&gt;early &amp;&amp; parameq(param, p-&gt;str)) || (strcmp(param, &quot;console&quot;) == 0 &amp;&amp; strcmp(p-&gt;str, &quot;earlycon&quot;) == 0) ) { if (p-&gt;setup_func(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\\n&quot;, param); } } /* We accept everything at this stage. */ return 0; } In summary, do_early_param executes setup_func registered by early_param by referring boot parameters. However, since it uses ELF symbols, it does not work correctly in JavaScript. For this reason, the function which will be called here is hard coded. static int __init do_early_param(char *param, char *val, const char *unused, void *arg) { /* XXX: There is a lot of early_param, but hardcode in init/main.c */ const char *early_params[MAX_INIT_ARGS+2] = { &quot;debug&quot;, &quot;quiet&quot;, &quot;loglevel&quot;, NULL, }; int i; for (i = 0; early_params[i]; i++) { if (strcmp(param, early_params[i]) == 0 || (strcmp(param, &quot;console&quot;) == 0 &amp;&amp; strcmp(early_params[i], &quot;earlycon&quot;) == 0) ) { switch (i) { case 0: /* debug */ if (debug_kernel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\\n&quot;, param); break; case 1: /* quiet */ if (quiet_kernel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\\n&quot;, param); break; case 2: /* loglevel */ if (loglevel(val) != 0) pr_warn(&quot;Malformed early option &#39;%s&#39;\\n&quot;, param); break; default: pr_warn(&quot;Unknown early option &#39;%s&#39;\\n&quot;, param); } } } /* We accept everything at this stage. */ return 0; } Fix initcall Like early_param, initcall which are called in the initialization manages functions using ELF symbols. With JavaScript alone, we can not know which function should be called. Therefore, we have to generate inticall tables from System.map generated by a normal build of LKL. with open(sys.argv[1], &quot;r&quot;) as fp: for line in fp: if SIG in line: symbol = line[:-1].split(&quot; &quot;)[2] try: level = int(symbol[-1]) initcall = symbol[symbol.index(SIG)+len(SIG):len(symbol)-1] initcalls[level].append(initcall) except ValueError: pass for level, row in enumerate(initcalls): print(&quot;/* initcall{} */&quot;.format(level)) print(&quot;EM_ASM({&quot;) for initcall in row: if initcall in blacklist: print(&quot; /* _&quot;+initcall+&quot;(); */&quot;) else: print(&quot; _&quot;+initcall+&quot;();&quot;) print(&quot;});&quot;) The above is the initcall table generation script. We hard-code the code to do_initcalls. EM_ASM is an inline assembly that directly calls the JavaScript code in C. static void __init do_initcalls(void) { /* XXX: initcalls are broken, so hardcode here */ /* initcall0 */ EM_ASM({ _net_ns_init(); }); /* initcall1 */ EM_ASM({ _lkl_console_init(); _wq_sysfs_init(); _ksysfs_init(); /* snip */ }); } Demonstration and the Results As described at the top, LKL.js uses pthread, we have to enable SharedArrayBuffer. Although every modern web browsers are shipped with SharedarrayBuffer, it is disabled by default because of Spectre mitigation in Mozilla Firefox. Therefore, please enable it before executing the demo. The following is the result of start_kernel. We can see that it shows dmesg on browsers. [ 0.000000] Linux version 4.16.0+ (akira@akira-Z270) () #13 Tue Jul 17 23:01:19 JST 2018 [ 0.000000] bootmem address range: 0x675000 - 0x1674000 [ 0.000000] On node 0 totalpages: 4095 [ 0.000000] Normal zone: 36 pages used for memmap [ 0.000000] Normal zone: 0 pages reserved [ 0.000000] Normal zone: 4095 pages, LIFO batch:0 [ 0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768 [ 0.000000] pcpu-alloc: [0] 0 [ 0.000000] Built 1 zonelists, mobility grouping off. Total pages: 4059 [ 0.000000] Kernel command line: mem=16M loglevel=8 [ 0.000000] Parameter is obsolete, ignored [ 0.000000] Parameter is obsolete, ignored [ 0.000000] Dentry cache hash table entries: 2048 (order: 1, 8192 bytes) [ 0.000000] Inode-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.000000] Memory available: 16144k/16380k RAM [ 0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1 [ 0.000000] NR_IRQS: 1024 [ 0.000000] lkl: irqs initialized [ 0.000000] clocksource: lkl: mask: 0xffffffffffffffff max_cycles: 0x1cd42e4dffb, max_idle_ns: 881590591483 ns [ 0.000100] lkl: time and timers initialized (irq1) [ 0.001100] pid_max: default: 4096 minimum: 301 [ 0.009400] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.009900] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.327100] console [lkl_console0] enabled [ 0.329600] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.329700] xor: automatically using best checksumming function 8regs [ 0.341199] NET: Registered protocol family 16 [ 0.388999] clocksource: Switched to clocksource lkl [ 0.414100] NET: Registered protocol family 2 [ 0.437700] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes) [ 0.438199] TCP established hash table entries: 1024 (order: 0, 4096 bytes) [ 0.439000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes) [ 0.439600] TCP: Hash tables configured (established 1024 bind 1024) [ 0.443200] UDP hash table entries: 256 (order: 0, 4096 bytes) [ 0.444000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes) [ 0.472100] workingset: timestamp_bits=30 max_order=12 bucket_order=0 [ 0.863100] SGI XFS with ACLs, security attributes, no debug enabled [ 0.923700] jitterentropy: Initialization failed with host not compliant with requirements: 2 [ 0.924599] io scheduler noop registered [ 0.924900] io scheduler deadline registered [ 0.933099] io scheduler cfq registered (default) [ 0.933500] io scheduler kyber registered [ 1.633500] NET: Registered protocol family 10 [ 1.658400] Segment Routing with IPv6 [ 1.660800] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver [ 1.674200] ------------[ cut here ]------------ [ 1.675500] WARNING: CPU: 0 PID: 0 at arch/lkl/kernel/setup.c:188 (null) [ 1.675899] Call Trace: [ 1.676200] [ 1.676999] ---[ end trace 941dc55fe0966cff ]--- [ 1.684299] Warning: unable to open an initial console. [ 1.685200] This architecture does not have kernel memory protection. pthread_join((pthread_t)tid, NULL): No such process lkl_start_kernel(&amp;lkl_host_ops, &quot;mem=16M loglevel=8&quot;) = 0 Limitations From the above results, we confirmed that Linux kernel was booted directly in JavaScript. However, it just outputted dmesg and it is not suitable for practical use at all. This is because of the following problems: It fails to create kernel threads. It fails to mount rootfs. It fails to execute init (PID 1). Also, support for pthreads in Emscripten is not good. We extracted semaphore, mutex, and thread from Little Kernel (LK) and add them to LKL as green threads. https://github.com/retrage/linux/tree/retrage/fiber We plan to create LKL.js using this green threads. Summary We created a Linux kernel fully translated in JavaScript using LKL and Emscripten. It boots the Linux kernel and we confirmed that it shows dmesg. Although the architecture is greatly different between computers and JavaScript, we found that it works somewhat by adding some fixes and workarounds. Reference https://github.com/lkl/linux https://github.com/kripken/emscripten https://llvm.org/ https://clang.llvm.org/ https://wiki.linuxfoundation.org/llvmlinux https://lwn.net/Articles/734071/ http://llvm.org/docs/CommandGuide/llvm-link.html https://0xax.gitbooks.io/linux-insides/Concepts/linux-cpu-3.html https://github.com/littlekernel/lk","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="めもちょー" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">めもちょー</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">LKL.js: Running Linux Kernel on JavaScript *Directly*</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-07-25T20:29:00+09:00" itemprop="datePublished">Jul 25, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I ported Linux kernel directly on JavaScript.
In other words, I translated the Linux kernel to JavaScript using Emscripten,
and Unlike JSLinux, it runs without emulators.</p>

<p><img src="/img/lkl-js-architecture.png" alt="LKL.js Architecture" /></p>

<p>The following is the working repository.</p>

<ul>
  <li>https://github.com/retrage/linux/tree/retrage/em-v2</li>
</ul>

<p>I published a demonstration site for LKL.js.
Please enable SharedArrayBuffer and try it out</p>

<ul>
  <li><a href="https://retrage.github.io/lkl-js">LKL.js Demo</a></li>
</ul>

<p>I also published slides about LKL.js.</p>

<ul>
  <li>https://speakerdeck.com/retrage/lkl-dot-js-running-linux-kernel-on-javascript-star-directly-star</li>
</ul>

<h2 id="linux-kernel-library-lkl">Linux Kernel Library (LKL)</h2>

<p>We use Linux Kernel Library (LKL) which makes the Linux kernel an anykernel.
LKL is a fork of torvalds/linux.
It is designed to put LKL specific code only in
<code class="highlighter-rouge">arch/lkl</code> and runs without modifications of other code.
By this design, it makes easy to follow the mainline. (Currently v4.16)
Since LKL is anykernel, it runs on user space of
various OS such as Linux, FreeBSD, and Windows etc.</p>

<h2 id="emscripten">Emscripten</h2>

<p>Emscripten is LLVM based C/C++ to 
JavaScript/WebAssembly transpiler.
It also provides a Unix-like environment to run translated software
on web browsers.</p>

<h2 id="can-we-port-lkl-to-javascript-with-emscripten">Can we port LKL to JavaScript with Emscripten?</h2>

<p>LKL runs on various OSes, Emscripten provides Unix-like
environment. So can LKL be ported to JavaScript with Emscripten?</p>

<h3 id="current-status-of-linux-kernel-build-with-clang">Current Status of Linux Kernel Build with Clang</h3>

<p>First of all, the Linux kernel is deeply dependent on 
gcc-extension, and there is a doubt that Clang can not compile it.
Once upon the time, there was LLVMLinux project that aims to compile
Linux kernel with Clang.
However, through the efforts of the Google Android team, two LTS (4.4 and 4.9)
can be built with Clang.
Now, LKL can be built with Clang.</p>

<h3 id="lkl-build-flow-101">LKL Build Flow 101</h3>

<p>Let’s look at the build flow of LKL.
First, when</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make <span class="nt">-C</span> tools/lkl
</code></pre></div></div>

<p>is performed, the build system determines which source code (*.c/*.S)
to be built from the Kconfig settings and compiles them.
Object files (*.o) generated by compiling are once archived by <code class="highlighter-rouge">ar</code>
to <code class="highlighter-rouge">built-in.o</code>.
Next, it links all <code class="highlighter-rouge">built-in.o</code> files into <code class="highlighter-rouge">vmlinux</code> at once.
For host side code, files under <code class="highlighter-rouge">tools/lkl/lib</code> compiled and linked
to <code class="highlighter-rouge">liblkl.o</code>.
Finally, link all files (<code class="highlighter-rouge">vmlinux</code> and <code class="highlighter-rouge">liblkl.o</code>) to <code class="highlighter-rouge">liblkl.so</code>.</p>

<p>This is a simple build flow of LKL.</p>

<h2 id="porting-lkl-with-emscripten">Porting LKL with Emscripten</h2>

<p>Next, we will take a look at how to port LKL with Emscripten.</p>

<p>Not limited to Emscripten, when using LLVM infrastructures,
the compiler compiles source to target with the following flow.</p>

<p>Soruce -&gt; LLVM IR -&gt; Target</p>

<p>In this way, the source is once converted to LLVM IR (*.bc/*.ll)
and then converted to the target.
In Emscripten, the “linking” is the conversion from LLVM IR to JavaScript.
Therefore, it is necessary to first convert all
(including libc etc. provided by Emscripten) to LLVM IR.</p>

<h3 id="generating-vmlinuxbc">Generating vmlinux.bc</h3>

<p>The build using <code class="highlighter-rouge">emcc</code> (An Emscripten Clang wrapper) is:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-C</span> tools/lkl <span class="nv">CC</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CC</span><span class="s2"> </span><span class="nv">$CFLAGS</span><span class="s2">"</span> <span class="nv">AR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY</span><span class="s2"> </span><span class="nv">$PWD</span><span class="s2">/ar.py"</span> <span class="nv">V</span><span class="o">=</span>1
</code></pre></div></div>

<p>The two important things here are <code class="highlighter-rouge">$FCFLAS</code> and <code class="highlighter-rouge">ar.py</code>.
I will explain each one.
(Note that <code class="highlighter-rouge">C="$CC $CFLAGS"</code> is forced to pass <code class="highlighter-rouge">$CFLAGS</code>)</p>

<p><code class="highlighter-rouge">$CFLAGS</code> is:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s WASM=0"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s ASYNCIFY=1"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s EMULATE_FUNCTION_POINTER_CASTS=1"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s USE_PTHREADS=1"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s PTHREAD_POOL_SIZE=4"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s TOTAL_MEMORY=1342177280"</span>
</code></pre></div></div>

<p>The options are to pass to Emscripten.
Please refer to the Emscripten manual for details.</p>

<p>Furthermore, the following definitions are specified.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DMAX_NR_ZONES=2"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DNR_PAGEFLAGS=20"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DSPINLOCK_SIZE=0"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DF_GETLK64=12"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DF_SETLK64=13"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DF_SETLKW64=14"</span>
</code></pre></div></div>

<p>These values are originally obtained by compiling an empty file
at the time of Linux kernel build. However, this time they can not be
obtained directly. Therefore, we have to specify these values
which come from when building with the x86_64 environment.</p>

<p>Next, I will explain <code class="highlighter-rouge">ar.py</code>. The following is a snippet of <code class="highlighter-rouge">ar.py</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filename</span> <span class="o">=</span> <span class="s">"objs"</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">".o"</span> <span class="ow">in</span> <span class="n">arg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s">"built-in"</span> <span class="ow">in</span> <span class="n">arg</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"aw"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span> <span class="ow">is</span> <span class="s">""</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="s">" "</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>As explained above, the build system of Linux kernel gathers object files
by <code class="highlighter-rouge">ar</code> and links them to get <code class="highlighter-rouge">vmlinux</code>.</p>

<p>To work with Emscripten we need to get <code class="highlighter-rouge">vmlinux</code> as a LLVM bitcode.
LLVM has a linker called <code class="highlighter-rouge">llvm-link</code> that links multiple LLVM bitcode files
to get one LLVM bitcode.
To generate <code class="highlighter-rouge">vmlinux.bc</code>, we need to use <code class="highlighter-rouge">llvm-link</code>,
but there is a problem.
<code class="highlighter-rouge">llvm-link</code> can not take archive files as arguments like <code class="highlighter-rouge">ld</code>s.
Therefore, we have to record object files that are originally archived.
In this case, <code class="highlighter-rouge">ar.py</code> will record them as file paths in <code class="highlighter-rouge">objs</code>.</p>

<p>Next, Let’s look at the part of <code class="highlighter-rouge">vmlinux.bc</code> generation.
I added following scripts to <code class="highlighter-rouge">scripts/link-vmlinux.sh</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>info CLEAN obj 
python <span class="s2">"</span><span class="k">${</span><span class="nv">srctree</span><span class="k">}</span><span class="s2">/clean-obj.py"</span>

info GEN link-vmlinux.sh
python <span class="s2">"</span><span class="k">${</span><span class="nv">srctree</span><span class="k">}</span><span class="s2">/link-vmlinux-gen.py"</span>

info LINK vmlinux
bash <span class="s2">"</span><span class="k">${</span><span class="nv">srctree</span><span class="k">}</span><span class="s2">/link-vmlinux.sh"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">clean-obj.py</code> removes duplicated file paths from <code class="highlighter-rouge">objs</code>
which is generated by <code class="highlighter-rouge">ar.py</code>.
<code class="highlighter-rouge">link-vmlinux-gen.py</code> generates <code class="highlighter-rouge">vmlinux-link.sh</code>
(not <code class="highlighter-rouge">scripts/link-vmlinux.sh</code>) which performs <code class="highlighter-rouge">llvm-link</code>.
By performing <code class="highlighter-rouge">vmlinux-link.sh</code>, we can get <code class="highlighter-rouge">vmlinux.bc</code>.</p>

<p>This is the flow of generating <code class="highlighter-rouge">vmlinux.bc</code>.</p>

<h3 id="generating-bootjs">Generating boot.js</h3>

<p>Next, I will look at until JavaScript code is generated.
As explained above, since LKL is one of Library OS,
<code class="highlighter-rouge">vmlinux</code> does not work on its own, it works only when it has
a part of an application. In this case, our target is <code class="highlighter-rouge">tools/lkl/tests/boot</code>
which is LKL’s <code class="highlighter-rouge">Hello, world</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$LINK</span> <span class="nt">-o</span> <span class="nv">$LKL</span>/tests/boot.bc <span class="se">\</span>
    <span class="nv">$LKL</span>/tests/boot-in.o <span class="nv">$LKL</span>/lib/liblkl-in.o <span class="nv">$LKL</span>/lib/lkl.o
</code></pre></div></div>

<p>First, we have to link <code class="highlighter-rouge">vmlinux.bc</code> (<code class="highlighter-rouge">$LKL/lib/lkl.o</code>),
host dependent part <code class="highlighter-rouge">$LKL/lib/liblkl-in.o</code> and
applicatin part <code class="highlighter-rouge">$LKL/tests/boot-in.o</code> and get <code class="highlighter-rouge">$LKL/tests/boot.bc</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$DIS</span> <span class="nt">-o</span> <span class="nv">$LKL</span>/tests/boot.ll <span class="nv">$LKL</span>/tests/boot.bc
<span class="nv">$CP</span> ~/.emscripten_cache/asmjs/dlmalloc.bc js/dlmalloc.bc
<span class="nv">$CP</span> ~/.emscripten_cache/asmjs/libc.bc js/libc.bc
<span class="nv">$CP</span> ~/.emscripten_cache/asmjs/pthreads.bc js/pthreads.bc
<span class="nv">$DIS</span> <span class="nt">-o</span> js/dlmalloc.ll js/dlmalloc.bc
<span class="nv">$DIS</span> <span class="nt">-o</span> js/libc.ll js/libc.bc
<span class="nv">$DIS</span> <span class="nt">-o</span> js/pthreads.ll js/pthreads.bc
<span class="nv">$PY</span> rename_symbols.py <span class="nv">$LKL</span>/tests/boot.ll <span class="nv">$LKL</span>/tests/boot-mod.ll
</code></pre></div></div>

<p>First, it disassembles all LLVM bitcode files
(<code class="highlighter-rouge">$LKL/tests/boot.bc</code> and <code class="highlighter-rouge">libc.bc</code> etc.)
using <code class="highlighter-rouge">llvm-dis</code>.
Next, it applies <code class="highlighter-rouge">rename_symbols.py</code> to <code class="highlighter-rouge">boot.ll</code>.</p>

<p>There is a reason for performing such operations.
This is because function names used in the Linux kernel conflict
with function names used in libcs.
In normal LKL, this conflict is avoided by using ELF linker tricks.
Meanwhile, since JavaScript generated by Emscripten does not
have a namespace, such collisions occur.
Therefore, by rewriting the functions names that would collide
with <code class="highlighter-rouge">rename_symbols.py</code>, it can avoid collisions.</p>

<p>In addition, <code class="highlighter-rouge">rename_symbols.py</code> also performs operations such as
converting inline assemblies in Linux kernel to Emscripten
<code class="highlighter-rouge">emscripten_asm_const_int</code>.</p>

<p>From the <code class="highlighter-rouge">boot-mod.ll</code>,</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">EMCC_DEBUG</span><span class="o">=</span>1 <span class="nv">$CC</span> <span class="nt">-o</span> js/boot.html <span class="nv">$LKL</span>/tests/boot-mod.ll <span class="nv">$CFLAGS</span> <span class="nt">-v</span>
</code></pre></div></div>

<p>generate HTML and JavaScript files.</p>

<h2 id="adding-workarounds">Adding Workarounds</h2>

<p>Although we generated the Linux kernel translated in “completely”
JavaScript and the application <code class="highlighter-rouge">boot.js</code>, it will not work as it is.
This is due to the fact that the architecture of computers and
JavaScript is very different. So we have to make some modifications.</p>

<h3 id="replacing-inline-assemblies">Replacing inline assemblies</h3>

<p>In the Linux kernel, the architecture-dependent code is basically placed
under <code class="highlighter-rouge">arch/$ARCH</code>, and other code are architecture independent.
However, an empty inline assembly may be inserted so that optimization
by the compiler prevents meaningful code from being lost at compile time.
Here is an example, <code class="highlighter-rouge">set_normalized_timespec64</code> in <code class="highlighter-rouge">kernel/time/time.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set_normalized_timespec64</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec64</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">time64_t</span> <span class="n">sec</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*
		 * The following asm() prevents the compiler from
		 * optimising this loop into a modulo operation. See
		 * also __iter_div_u64_rem() in include/linux/time.h
		 */</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">""</span> <span class="o">:</span> <span class="s">"+rm"</span><span class="p">(</span><span class="n">nsec</span><span class="p">));</span>
		<span class="n">nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="o">++</span><span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">""</span> <span class="o">:</span> <span class="s">"+rm"</span><span class="p">(</span><span class="n">nsec</span><span class="p">));</span>
		<span class="n">nsec</span> <span class="o">+=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="o">--</span><span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sec</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Such Inline assemblies cause a failure to convert from LLVM bitcode to
JavaScript. Therefore, we have to replace inline assemblies such as
<code class="highlighter-rouge">asm("" : "+rm"(nsec))</code> with <code class="highlighter-rouge">emcsripten_asm_const_int</code>
which calls JavaScript code from C defined in Emscripten.</p>

<h3 id="fix-early_param">Fix early_param</h3>

<p>In the Linux kernel, there is <code class="highlighter-rouge">early_param</code>.
This is defined in <code class="highlighter-rouge">include/linux/init.h</code> as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_func</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">early</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* snip */</span>
<span class="cp">#define __setup_param(str, unique_id, fn, early)			\
	static const char __setup_str_##unique_id[] __initconst		\
		__aligned(1) = str; 					\
	static struct obs_kernel_param __setup_##unique_id		\
		__used __section(.init.setup)				\
		__attribute__((aligned((sizeof(long)))))		\
		= { __setup_str_##unique_id, fn, early }
</span><span class="cm">/* snip */</span>
<span class="cp">#define early_param(str, fn)						\
	__setup_param(str, fn, fn, 1)
</span></code></pre></div></div>

<p><code class="highlighter-rouge">early_param</code> is a macro, taking <code class="highlighter-rouge">str</code> and <code class="highlighter-rouge">fn</code> as arguments,
and <code class="highlighter-rouge">obs_kernel_param</code> structure placed in <code class="highlighter-rouge">.init.setup</code>.</p>

<p>By referring to <code class="highlighter-rouge">arch/lkl/kernel/vmlinux.ldS</code> which is generated
in the build of LKL, we can see that <code class="highlighter-rouge">.init.setup</code> is arranged
between <code class="highlighter-rouge">__setup_start</code> and <code class="highlighter-rouge">__setup_end</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__setup_start = .; KEEP(*(.init.setup)) __setup_end = .;
</code></pre></div></div>

<p>These symbols will be used in <code class="highlighter-rouge">init/main.c</code> as follows.
Here it compares one of boot parameter (<code class="highlighter-rouge">param</code>) of Linux kernel
with <code class="highlighter-rouge">str</code> of <code class="highlighter-rouge">obs_kernel_param</code> in <code class="highlighter-rouge">.init.setup</code>.
If it matches, it will execute <code class="highlighter-rouge">(*setup_func)(char*)</code> with argument <code class="highlighter-rouge">val</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Check for early params. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_early_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">__setup_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">__setup_end</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">early</span> <span class="o">&amp;&amp;</span> <span class="n">parameq</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">"console"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		     <span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="s">"earlycon"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">setup_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* We accept everything at this stage. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In summary, <code class="highlighter-rouge">do_early_param</code> executes <code class="highlighter-rouge">setup_func</code> registered by
<code class="highlighter-rouge">early_param</code> by referring boot parameters.</p>

<p>However, since it uses ELF symbols, it does not work correctly
in JavaScript. For this reason, the function which will be called here
is hard coded.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_early_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* XXX: There is a lot of early_param, but hardcode in init/main.c */</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">early_params</span><span class="p">[</span><span class="n">MAX_INIT_ARGS</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"debug"</span><span class="p">,</span> <span class="s">"quiet"</span><span class="p">,</span> <span class="s">"loglevel"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">early_params</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">early_params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">"console"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                     <span class="n">strcmp</span><span class="p">(</span><span class="n">early_params</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"earlycon"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span> <span class="p">{</span>
                        <span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="cm">/* debug */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">debug_kernel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                                <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="cm">/* quiet */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">quiet_kernel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                                <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="cm">/* loglevel */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">loglevel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                                <span class="nl">default:</span>
                                <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Unknown early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>

	<span class="cm">/* We accept everything at this stage. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="fix-initcall">Fix initcall</h3>

<p>Like <code class="highlighter-rouge">early_param</code>, <code class="highlighter-rouge">initcall</code> which are called in the initialization
manages functions using ELF symbols.
With JavaScript alone, we can not know which function should be called.
Therefore, we have to generate inticall tables from <code class="highlighter-rouge">System.map</code>
generated by a normal build of LKL.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">SIG</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">" "</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">initcall</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">[</span><span class="n">symbol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">SIG</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">SIG</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">initcalls</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initcall</span><span class="p">)</span>
                <span class="k">except</span> <span class="nb">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initcalls</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"/* initcall{} */"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"EM_ASM({"</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">initcall</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initcall</span> <span class="ow">in</span> <span class="n">blacklist</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"    /* _"</span><span class="o">+</span><span class="n">initcall</span><span class="o">+</span><span class="s">"(); */"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"    _"</span><span class="o">+</span><span class="n">initcall</span><span class="o">+</span><span class="s">"();"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"});"</span><span class="p">)</span>
</code></pre></div></div>

<p>The above is the initcall table generation script.
We hard-code the code to <code class="highlighter-rouge">do_initcalls</code>.
<code class="highlighter-rouge">EM_ASM</code> is an inline assembly that directly calls the JavaScript code
in C.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_initcalls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* XXX: initcalls are broken, so hardcode here */</span>
        <span class="cm">/* initcall0 */</span>
        <span class="n">EM_ASM</span><span class="p">({</span>
            <span class="n">_net_ns_init</span><span class="p">();</span>
        <span class="p">});</span>
        <span class="cm">/* initcall1 */</span>
        <span class="n">EM_ASM</span><span class="p">({</span>
            <span class="n">_lkl_console_init</span><span class="p">();</span>
            <span class="n">_wq_sysfs_init</span><span class="p">();</span>
            <span class="n">_ksysfs_init</span><span class="p">();</span>
<span class="cm">/* snip */</span>
        <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="demonstration-and-the-results">Demonstration and the Results</h2>

<p>As described at the top, LKL.js uses pthread,
we have to enable SharedArrayBuffer.
Although every modern web browsers are shipped with SharedarrayBuffer,
it is disabled by default because of Spectre mitigation in Mozilla Firefox.
Therefore, please enable it before executing the demo.</p>

<p>The following is the result of <code class="highlighter-rouge">start_kernel</code>.
We can see that it shows dmesg on browsers.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [    0.000000] Linux version 4.16.0+ (akira@akira-Z270) () #13 Tue Jul 17 23:01:19 JST 2018
  [    0.000000] bootmem address range: 0x675000 - 0x1674000
  [    0.000000] On node 0 totalpages: 4095
  [    0.000000]   Normal zone: 36 pages used for memmap
  [    0.000000]   Normal zone: 0 pages reserved
  [    0.000000]   Normal zone: 4095 pages, LIFO batch:0
  [    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
  [    0.000000] pcpu-alloc: [0] 0 
  [    0.000000] Built 1 zonelists, mobility grouping off.  Total pages: 4059
  [    0.000000] Kernel command line: mem=16M loglevel=8
  [    0.000000] Parameter  is obsolete, ignored
  [    0.000000] Parameter  is obsolete, ignored
  [    0.000000] Dentry cache hash table entries: 2048 (order: 1, 8192 bytes)
  [    0.000000] Inode-cache hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.000000] Memory available: 16144k/16380k RAM
  [    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
  [    0.000000] NR_IRQS: 1024
  [    0.000000] lkl: irqs initialized
  [    0.000000] clocksource: lkl: mask: 0xffffffffffffffff max_cycles: 0x1cd42e4dffb, max_idle_ns: 881590591483 ns
  [    0.000100] lkl: time and timers initialized (irq1)
  [    0.001100] pid_max: default: 4096 minimum: 301
  [    0.009400] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.009900] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.327100] console [lkl_console0] enabled
  [    0.329600] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
  [    0.329700] xor: automatically using best checksumming function   8regs     
  [    0.341199] NET: Registered protocol family 16
  [    0.388999] clocksource: Switched to clocksource lkl
  [    0.414100] NET: Registered protocol family 2
  [    0.437700] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes)
  [    0.438199] TCP established hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.439000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.439600] TCP: Hash tables configured (established 1024 bind 1024)
  [    0.443200] UDP hash table entries: 256 (order: 0, 4096 bytes)
  [    0.444000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
  [    0.472100] workingset: timestamp_bits=30 max_order=12 bucket_order=0
  [    0.863100] SGI XFS with ACLs, security attributes, no debug enabled
  [    0.923700] jitterentropy: Initialization failed with host not compliant with requirements: 2
  [    0.924599] io scheduler noop registered
  [    0.924900] io scheduler deadline registered
  [    0.933099] io scheduler cfq registered (default)
  [    0.933500] io scheduler kyber registered
  [    1.633500] NET: Registered protocol family 10
  [    1.658400] Segment Routing with IPv6
  [    1.660800] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
  [    1.674200] ------------[ cut here ]------------
  [    1.675500] WARNING: CPU: 0 PID: 0 at arch/lkl/kernel/setup.c:188   (null)
  [    1.675899] Call Trace:
  [    1.676200] 
  [    1.676999] ---[ end trace 941dc55fe0966cff ]---
  [    1.684299] Warning: unable to open an initial console.
  [    1.685200] This architecture does not have kernel memory protection.
  pthread_join((pthread_t)tid, NULL): No such process
  lkl_start_kernel(&amp;lkl_host_ops, "mem=16M loglevel=8") = 0 
</code></pre></div></div>

<h2 id="limitations">Limitations</h2>

<p>From the above results, we confirmed that Linux kernel was booted
directly in JavaScript.
However, it just outputted dmesg and
it is not suitable for practical use at all.
This is because of the following problems:</p>

<ul>
  <li>It fails to create kernel threads.</li>
  <li>It fails to mount rootfs.</li>
  <li>It fails to execute init (PID 1).</li>
</ul>

<p>Also, support for pthreads in Emscripten is not good.
We extracted semaphore, mutex, and thread from Little Kernel (LK)
and add them to LKL as green threads.</p>

<ul>
  <li>https://github.com/retrage/linux/tree/retrage/fiber</li>
</ul>

<p>We plan to create LKL.js using this green threads.</p>

<h2 id="summary">Summary</h2>

<p>We created a Linux kernel fully translated in JavaScript using
LKL and Emscripten. It boots the Linux kernel and we confirmed
that it shows dmesg.
Although the architecture is greatly different between
computers and JavaScript, we found that it works somewhat by adding
some fixes and workarounds.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li>https://github.com/lkl/linux</li>
  <li>https://github.com/kripken/emscripten</li>
  <li>https://llvm.org/</li>
  <li>https://clang.llvm.org/</li>
  <li>https://wiki.linuxfoundation.org/llvmlinux</li>
  <li>https://lwn.net/Articles/734071/</li>
  <li>http://llvm.org/docs/CommandGuide/llvm-link.html</li>
  <li>https://0xax.gitbooks.io/linux-insides/Concepts/linux-cpu-3.html</li>
  <li>https://github.com/littlekernel/lk</li>
</ul>

  </div><a class="u-url" href="/2018/07/25/lkl-js-en.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">めもちょー</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">めもちょー</li><li><a class="u-email" href="mailto:retrage01@gmail.com">retrage01@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/retrage"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">retrage</span></a></li><li><a href="https://www.twitter.com/retrage01"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">retrage01</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Mirror of http://retrage01.hateblo.jp/ Blog post in Japanese by @retrage01</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
