<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>LKL.js: Linux kernelを直接JavaScript上で動かす | retrage.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="LKL.js: Linux kernelを直接JavaScript上で動かす" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux kernelを直接JavaScript上で動かした． つまり，JSLinuxのようにEmulatorをJavaScriptで作成し， その上でLinuxを動かすのではなく， JavaScriptで書かれたLinuxを生成し，それを動かす，ということである．" />
<meta property="og:description" content="Linux kernelを直接JavaScript上で動かした． つまり，JSLinuxのようにEmulatorをJavaScriptで作成し， その上でLinuxを動かすのではなく， JavaScriptで書かれたLinuxを生成し，それを動かす，ということである．" />
<link rel="canonical" href="/2018/07/21/lkl-js.html" />
<meta property="og:url" content="/2018/07/21/lkl-js.html" />
<meta property="og:site_name" content="retrage.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-21T15:30:00+09:00" />
<script type="application/ld+json">
{"datePublished":"2018-07-21T15:30:00+09:00","dateModified":"2018-07-21T15:30:00+09:00","url":"/2018/07/21/lkl-js.html","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/07/21/lkl-js.html"},"description":"Linux kernelを直接JavaScript上で動かした． つまり，JSLinuxのようにEmulatorをJavaScriptで作成し， その上でLinuxを動かすのではなく， JavaScriptで書かれたLinuxを生成し，それを動かす，ということである．","@type":"BlogPosting","headline":"LKL.js: Linux kernelを直接JavaScript上で動かす","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="retrage.github.io" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">retrage.github.io</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">LKL.js: Linux kernelを直接JavaScript上で動かす</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-07-21T15:30:00+09:00" itemprop="datePublished">Jul 21, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Linux kernelを直接JavaScript上で動かした．
つまり，JSLinuxのようにEmulatorをJavaScriptで作成し，
その上でLinuxを動かすのではなく，
JavaScriptで書かれたLinuxを生成し，それを動かす，ということである．</p>

<p><img src="/img/lkl-js-architecture.png" alt="lkl.js Architecture" /></p>

<p>リポジトリは以下の通り．</p>

<ul>
  <li>https://github.com/retrage/linux/tree/retrage/em-v2</li>
</ul>

<p>なお
<a href="https://retrage.github.io/lkl-js/">lkl.js Demo</a>
にデモを用意した．
SharedArrayBufferを有効にして試してみてほしい．</p>

<h2 id="linux-kernel-library-lkl">Linux Kernel Library (LKL)</h2>

<p>ここでは，Linux kernelをLibrary OSの形態の1つであるAnykernelにする
Linux Kernel Library (LKL)を利用する．
LKLはLinux kernelのforkとして存在し，<code class="highlighter-rouge">arch/lkl</code>にのみLKL specificな
コードをおき，その他は全く変更を加えずに動作するように設計されている．
これによりmainlineへの追従性を高めている．(現在はv4.16)
LKLはAnykernelであるので，
LinuxやFreeBSD, Windowsなど様々なOSのユーザ空間で動作する．</p>

<h2 id="emscripten">Emscripten</h2>

<p>EmscriptenはLLVMを利用したC/C++からJavaScript/WebAssemblyへのトランスパイラである．
Emscriptenはlibcやpthreadなどへも対応しており，Unix-likeな環境を用意している．</p>

<h2 id="lklをemscriptenでjavascriptに移植できるか">LKLをEmscriptenでJavaScriptに移植できるか？</h2>

<p>LKLは様々なOSで動作し，EmscriptenはUnix-likeな環境を用意する．
では，LKLはEmscriptenでJavaScriptに移植することはできるだろうか．</p>

<h2 id="移植する前に">移植する前に</h2>

<h3 id="clangでのlinux-kernelのビルドの現状">clangでのLinux kernelのビルドの現状</h3>

<p>そもそもLinux kernelとは，gcc拡張に依存しており，
clangなどではそもそも扱えないのでは，という疑問がある．
かつてLLVM Linuxというプロジェクトが立ち上がるぐらいには
Linux kernelをclangでコンパイルするのは困難であった．
しかし，2017年頃より，Androidの開発者らにより，
Linux kernelがclangでもコンパイル可能となった．</p>

<h3 id="linux-kernelのビルドの流れ">Linux kernelのビルドの流れ</h3>

<p>Linux kernelのビルドの流れをみていく．
最初に，makeが行われると，kconfigの設定からビルドされるソースコード(<em>.c/</em>.S)が決定され，
コンパイルが行われる．コンパイルにより生成されたオブジェクトファイル(*.o)は
一度機能ごとにarにより<code class="highlighter-rouge">built-in.o</code>などの名前でアーカイブ化される．
最後に，まとめて得られた<code class="highlighter-rouge">built-in.o</code>をリンクすることにより<code class="highlighter-rouge">vmlinux</code>を得る．
以上がLinux kernelにおける簡単なビルドの流れとなっている．</p>

<h2 id="lklをemscriptenで移植">LKLをEmscriptenで移植</h2>

<p>では，実際にどのようにLKLをEmscriptenで移植していくのかをみていく．</p>

<p>Emscriptenに限らず，LLVMを利用する場合，次のような流れでターゲットにコンパイルする．</p>

<p>Source -&gt; LLVM IR -&gt; Target</p>

<p>このように一度LLVM IR (<em>.bc/</em>.ll)に変換してからターゲットに変換される．
なお，Emscriptenでは通常のリンクに当たる部分がLLVM IRからJavaScriptへの変換となっている．
このため，最初に全て(Emscriptenの用意するlibcなども含めて)をLLVM IRに変換する必要がある．</p>

<h3 id="vmliuxbcの生成">vmliux.bcの生成</h3>

<p>emcc (Emscripten clangのwrapper)でのビルドは次のようになっている</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-C</span> tools/lkl <span class="nv">CC</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CC</span><span class="s2"> </span><span class="nv">$CFLAGS</span><span class="s2">"</span> <span class="nv">AR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PY</span><span class="s2"> </span><span class="nv">$PWD</span><span class="s2">/ar.py"</span> <span class="nv">V</span><span class="o">=</span>1
</code></pre></div></div>

<p>ここで重要なのが<code class="highlighter-rouge">$CFLAGS</code>と<code class="highlighter-rouge">ar.py</code>の2つである．それぞれみていく．
(なお，<code class="highlighter-rouge">CC="$CC $CFLAGS"</code>となっているのは無理やりCFLAGSを渡すためである)</p>

<p><code class="highlighter-rouge">$CFLAGS</code>は次のようになっている．</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s WASM=0"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s ASYNCIFY=1"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s EMULATE_FUNCTION_POINTER_CASTS=1"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s USE_PTHREADS=1"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s PTHREAD_POOL_SIZE=4"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -s TOTAL_MEMORY=1342177280"</span>
</code></pre></div></div>

<p>ここでは，Emscriptenに渡すオプションを指定している．
詳細についてはEmscriptenのマニュアルを参考にしてほしい．</p>

<p>さらに以下のような定義を指定している．</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DMAX_NR_ZONES=2"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DNR_PAGEFLAGS=20"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DSPINLOCK_SIZE=0"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DF_GETLK64=12"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DF_SETLK64=13"</span>
<span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$CFLAGS</span><span class="s2"> -DF_SETLKW64=14"</span>
</code></pre></div></div>

<p>これらは本来Linux kernelビルド時に空のファイルをコンパイルするなど
して得られる値であり，今回の場合，これらは直接得ることができない．
そのため，あらかじめx86_64でビルドしたときに得られた値をここで指定している．</p>

<p>次に<code class="highlighter-rouge">ar.py</code>をみていく．以下のような簡単なものとなっている．</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filename</span> <span class="o">=</span> <span class="s">"objs"</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">".o"</span> <span class="ow">in</span> <span class="n">arg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s">"built-in"</span> <span class="ow">in</span> <span class="n">arg</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"aw"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span> <span class="ow">is</span> <span class="s">""</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="s">" "</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>先に説明したように，本来Linux kernelでは
コンパイルによって得られたオブジェクトファイルを
<code class="highlighter-rouge">ar</code>によりまとめ，最後にリンクを行うことで<code class="highlighter-rouge">vmlinux</code>を得る．</p>

<p>Emscriptenで扱うには<code class="highlighter-rouge">vmlinux</code>をLLVM bitcodeとして得る必要がある．
LLVMには<code class="highlighter-rouge">llvm-link</code>という複数のLLVM bitcodeファイルをリンクして
1つのLLVM bitcodeを得るリンカが存在する．
<code class="highlighter-rouge">vmlinux.bc</code>を得るには<code class="highlighter-rouge">llvm-link</code>を利用する必要があるが，
ここで1つ問題がある．<code class="highlighter-rouge">llvm-link</code>は通常のリンカのように，
アーカイブファイルを引数としてとることができない．
そのため，本来アーカイブにされるオブジェクトファイルを記録しておく必要がある．
ここでは，<code class="highlighter-rouge">objs</code>にそれらをまとめてファイルパスとして記録しておく．</p>

<p>次に実際に<code class="highlighter-rouge">vmlinux.bc</code>が生成される部分をみていく．
<code class="highlighter-rouge">scripts/link-vmlinux.sh</code>に次のような変更が加えられている．</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>info CLEAN obj 
python <span class="s2">"</span><span class="k">${</span><span class="nv">srctree</span><span class="k">}</span><span class="s2">/clean-obj.py"</span>

info GEN link-vmlinux.sh
python <span class="s2">"</span><span class="k">${</span><span class="nv">srctree</span><span class="k">}</span><span class="s2">/link-vmlinux-gen.py"</span>

info LINK vmlinux
bash <span class="s2">"</span><span class="k">${</span><span class="nv">srctree</span><span class="k">}</span><span class="s2">/link-vmlinux.sh"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">clean-obj.py</code>では先に得られた<code class="highlighter-rouge">objs</code>より重複するファイルパスを削除する．
次に<code class="highlighter-rouge">link-vmlinux-gen.py</code>では<code class="highlighter-rouge">objs</code>より<code class="highlighter-rouge">llvm-link</code>を行う
<code class="highlighter-rouge">vmlinux-link.sh</code>(<code class="highlighter-rouge">scripts/link-vmlinux.sh</code>とは異なる)を生成する．
最後に<code class="highlighter-rouge">link-vmlinux.sh</code>を実行し，<code class="highlighter-rouge">vmlinux.bc</code>を得る．</p>

<p>以上が<code class="highlighter-rouge">vmlinux.bc</code>を得るまでの流れとなっている．</p>

<h3 id="bootjsの生成">boot.jsの生成</h3>

<p>次に実際にJavaScriptが生成されるまでをみていく．
先に説明したとおり，LKLはLibray OSの1つであるので，<code class="highlighter-rouge">vmlinux</code>それ単体では動作せず，
アプリケーションとなる部分があってはじめて動作する．ここでは，LKLのHello, worldに相当する
<code class="highlighter-rouge">tools/lkl/tests/boot</code>をターゲットとする．</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$LINK</span> <span class="nt">-o</span> <span class="nv">$LKL</span>/tests/boot.bc <span class="se">\</span>
    <span class="nv">$LKL</span>/tests/boot-in.o <span class="nv">$LKL</span>/lib/liblkl-in.o <span class="nv">$LKL</span>/lib/lkl.o
</code></pre></div></div>

<p>まず，先に生成した<code class="highlighter-rouge">vmlinux.bc</code> (<code class="highlighter-rouge">$LKL/lib/lkl.o</code>)と
ホスト依存部分<code class="highlighter-rouge">$LKL/lib/liblkl-in.o</code>，
アプリケーション部分<code class="highlighter-rouge">$LKL/tests/boot-in.o</code>をリンクして<code class="highlighter-rouge">$LKL/tests/boot.bc</code>を得る．</p>

<p>次に以下のようなことを行う．</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$DIS</span> <span class="nt">-o</span> <span class="nv">$LKL</span>/tests/boot.ll <span class="nv">$LKL</span>/tests/boot.bc
<span class="nv">$CP</span> ~/.emscripten_cache/asmjs/dlmalloc.bc js/dlmalloc.bc
<span class="nv">$CP</span> ~/.emscripten_cache/asmjs/libc.bc js/libc.bc
<span class="nv">$CP</span> ~/.emscripten_cache/asmjs/pthreads.bc js/pthreads.bc
<span class="nv">$DIS</span> <span class="nt">-o</span> js/dlmalloc.ll js/dlmalloc.bc
<span class="nv">$DIS</span> <span class="nt">-o</span> js/libc.ll js/libc.bc
<span class="nv">$DIS</span> <span class="nt">-o</span> js/pthreads.ll js/pthreads.bc
<span class="nv">$PY</span> rename_symbols.py <span class="nv">$LKL</span>/tests/boot.ll <span class="nv">$LKL</span>/tests/boot-mod.ll
</code></pre></div></div>

<p>最初に<code class="highlighter-rouge">boot.bc</code>を<code class="highlighter-rouge">llvm-dis</code>を用いてLLVM bitcodeからLLVM IRへ変換する．
次にEmscriptenの<code class="highlighter-rouge">dlmalloc.bc</code>や<code class="highlighter-rouge">libc.bc</code>，<code class="highlighter-rouge">pthreads.bc</code>などのファイルを
LLVM IRへと変換する．
最後に<code class="highlighter-rouge">rename_symbols.py</code>を<code class="highlighter-rouge">boot.ll</code>に対して実行する．
このようなことを行うのには理由がある．
それは，Linux kernelで利用されている関数名とlibcなどで利用されている関数名が
衝突してしまうからである．
通常のLKLでは，ELFの仕様を利用しうまくLinux kernelの関数を隠匿化することにより
この衝突を回避している．一方で，Emscriptenでは名前空間などが存在しないために，
このような衝突が発生してしまう．
そこで，あらかじめリンクされる予定のLLVM bitcodeをLLVM IRに変換し，
衝突するであろう関数名を<code class="highlighter-rouge">rename_symbols.py</code>で書き換えることにより衝突を回避している．</p>

<p>また，<code class="highlighter-rouge">rename_symbols.py</code>では，
Linux kernelに含まれる，inline asmをEmscriptenの<code class="highlighter-rouge">emscripten_asm_const_int</code>
に変換するなどの操作も行なっている．</p>

<p>以上によって得られた<code class="highlighter-rouge">boot-mod.ll</code>より</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">EMCC_DEBUG</span><span class="o">=</span>1 <span class="nv">$CC</span> <span class="nt">-o</span> js/boot.html <span class="nv">$LKL</span>/tests/boot-mod.ll <span class="nv">$CFLAGS</span> <span class="nt">-v</span>
</code></pre></div></div>

<p>によりHTMLとJSを得る．</p>

<h2 id="動かすための修正">動かすための修正</h2>

<p>以上により得られた「完全に」JavaScriptで書かれたLinux kernelとそれを利用した
アプリケーションboot.jsであるが，このままでは動作しない．
これは，通常のマシンとJavaScriptとではそもそものアーキテクチャが
大きく異なっていることに由来する．それでもいくつかの修正を加える．</p>

<h3 id="inline-assemblyの置換">inline assemblyの置換</h3>

<p>Linux kernelでは基本的に<code class="highlighter-rouge">arch</code>以下にアーキテクチャ依存のコードをおき，
それ以外ではアーキテクチャ非依存のコードとなるように配置されている．
しかし，一部のコードでは，コンパイラによる最適化により意味のあるコードが
コンパイル時に失われないように空のinline assemblyが挿入されている場合がある．
以下はその一例，<code class="highlighter-rouge">kernel/time/time.c</code>の<code class="highlighter-rouge">set_normalized_timespec64</code>である．</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set_normalized_timespec64</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec64</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">time64_t</span> <span class="n">sec</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*
		 * The following asm() prevents the compiler from
		 * optimising this loop into a modulo operation. See
		 * also __iter_div_u64_rem() in include/linux/time.h
		 */</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">""</span> <span class="o">:</span> <span class="s">"+rm"</span><span class="p">(</span><span class="n">nsec</span><span class="p">));</span>
		<span class="n">nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="o">++</span><span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asm</span><span class="p">(</span><span class="s">""</span> <span class="o">:</span> <span class="s">"+rm"</span><span class="p">(</span><span class="n">nsec</span><span class="p">));</span>
		<span class="n">nsec</span> <span class="o">+=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="o">--</span><span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sec</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>このようなinline assemblyはLLVM bitcodeからJavaScriptへの変換に失敗する要因となる．
このため，<code class="highlighter-rouge">asm("" : "+rm"(nsec));</code>をEmscriptenで定義されている
CからJSのコードを呼ぶinline assembly<code class="highlighter-rouge">emscripten_asm_const_int</code>に置き換えることで対応する．</p>

<h3 id="early_paramの修正">early_paramの修正</h3>

<p>Linux kernelでは，<code class="highlighter-rouge">early_param</code>というものが存在する．
これは，<code class="highlighter-rouge">include/linux/init.h</code>に以下のように定義される．</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_func</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">early</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* snip */</span>
<span class="cp">#define __setup_param(str, unique_id, fn, early)			\
	static const char __setup_str_##unique_id[] __initconst		\
		__aligned(1) = str; 					\
	static struct obs_kernel_param __setup_##unique_id		\
		__used __section(.init.setup)				\
		__attribute__((aligned((sizeof(long)))))		\
		= { __setup_str_##unique_id, fn, early }
</span><span class="cm">/* snip */</span>
<span class="cp">#define early_param(str, fn)						\
	__setup_param(str, fn, fn, 1)
</span></code></pre></div></div>

<p>つまり，<code class="highlighter-rouge">early_param</code>はマクロであり，<code class="highlighter-rouge">str</code>と<code class="highlighter-rouge">fn</code>を引数にとり，
<code class="highlighter-rouge">.init.setup</code>セクションに置かれる<code class="highlighter-rouge">obs_kernel_param</code>構造体であることがわかる．</p>

<p>通常のLKLのビルドで生成される<code class="highlighter-rouge">arch/lkl/kernel/vmlinux.lds</code>を参照すると
以下のようであることから，<code class="highlighter-rouge">.init.setup</code>は<code class="highlighter-rouge">__setup_start</code>と<code class="highlighter-rouge">__setup_end</code>で
挟まれたように配置されることがわかる．</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__setup_start = .; KEEP(*(.init.setup)) __setup_end = .;
</code></pre></div></div>

<p>これらのシンボルは<code class="highlighter-rouge">init/main.c</code>において次のように使われる．
ここでは，Linux kernelのboot parameter(<code class="highlighter-rouge">param</code>)の1つについて，
<code class="highlighter-rouge">.init.setup</code>にある<code class="highlighter-rouge">obs_kernel_param</code>の<code class="highlighter-rouge">str</code>と比較を行い，
一致した場合に設定してある<code class="highlighter-rouge">(*setup_func)(char*)</code>を
<code class="highlighter-rouge">val</code>を引数として実行している．</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Check for early params. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_early_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">__setup_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">__setup_end</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">early</span> <span class="o">&amp;&amp;</span> <span class="n">parameq</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">"console"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		     <span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="s">"earlycon"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">setup_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* We accept everything at this stage. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>まとめると，<code class="highlighter-rouge">do_early_param</code>では<code class="highlighter-rouge">early_param</code>によって登録されている
<code class="highlighter-rouge">setup_func</code>をboot parameterにより実行する，という形になっている．</p>

<p>ただ，これはELFのシンボルを利用しているために，JavaScriptでは正しく実行されない．
このため，ここで呼ばれるであろう関数について，以下のようにハードコードする．</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_early_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* XXX: There is a lot of early_param, but hardcode in init/main.c */</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">early_params</span><span class="p">[</span><span class="n">MAX_INIT_ARGS</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"debug"</span><span class="p">,</span> <span class="s">"quiet"</span><span class="p">,</span> <span class="s">"loglevel"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">early_params</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">early_params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">"console"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                     <span class="n">strcmp</span><span class="p">(</span><span class="n">early_params</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"earlycon"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span> <span class="p">{</span>
                        <span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="cm">/* debug */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">debug_kernel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                                <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="cm">/* quiet */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">quiet_kernel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                                <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="cm">/* loglevel */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">loglevel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                        <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Malformed early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                                <span class="nl">default:</span>
                                <span class="n">pr_warn</span><span class="p">(</span><span class="s">"Unknown early option '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>

	<span class="cm">/* We accept everything at this stage. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="initcallの修正">initcallの修正</h3>

<p>先の<code class="highlighter-rouge">early_param</code>同様，初期化で呼ばれる<code class="highlighter-rouge">initcall</code>も
ELFのシンボルを用いて呼ばれる関数を管理している．
JavaScript単体では，どの関数が呼ばれるべきかはわからない．
そのため，通常のLKLのビルドで生成される<code class="highlighter-rouge">System.map</code>
を用いて関数をあらかじめ取得し，そこから関数呼び出しを行う．</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">SIG</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">" "</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">symbol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">initcall</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">[</span><span class="n">symbol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">SIG</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">SIG</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">initcalls</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initcall</span><span class="p">)</span>
                <span class="k">except</span> <span class="nb">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initcalls</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"/* initcall{} */"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"EM_ASM({"</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">initcall</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initcall</span> <span class="ow">in</span> <span class="n">blacklist</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"    /* _"</span><span class="o">+</span><span class="n">initcall</span><span class="o">+</span><span class="s">"(); */"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"    _"</span><span class="o">+</span><span class="n">initcall</span><span class="o">+</span><span class="s">"();"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"});"</span><span class="p">)</span>
</code></pre></div></div>

<p>これによって得られるコードを<code class="highlighter-rouge">do_initcalls</code>にハードコードする．
<code class="highlighter-rouge">EM_ASM</code>はCにJSのコード直接記述するinline assemblyである．</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_initcalls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* XXX: initcalls are broken, so hardcode here */</span>
        <span class="cm">/* initcall0 */</span>
        <span class="n">EM_ASM</span><span class="p">({</span>
            <span class="n">_net_ns_init</span><span class="p">();</span>
        <span class="p">});</span>
        <span class="cm">/* initcall1 */</span>
        <span class="n">EM_ASM</span><span class="p">({</span>
            <span class="n">_lkl_console_init</span><span class="p">();</span>
            <span class="n">_wq_sysfs_init</span><span class="p">();</span>
            <span class="n">_ksysfs_init</span><span class="p">();</span>
<span class="cm">/* snip */</span>
        <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="デモと結果">デモと結果</h2>

<p>冒頭で紹介したように，lkl.jsではpthreadを利用しているため，
SharedArrayBufferを有効にする必要がある．
現在のブラウザではSharedArrayBufferが実装されているものの，
Spectreのmitiagtionのため，デフォルトでは無効になっている．
そのためこれを有効にした上で実行してみてほしい．</p>

<p><code class="highlighter-rouge">start_kernel</code>の実行結果を以下に示す．</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [    0.000000] Linux version 4.16.0+ (akira@akira-Z270) () #13 Tue Jul 17 23:01:19 JST 2018
  [    0.000000] bootmem address range: 0x675000 - 0x1674000
  [    0.000000] On node 0 totalpages: 4095
  [    0.000000]   Normal zone: 36 pages used for memmap
  [    0.000000]   Normal zone: 0 pages reserved
  [    0.000000]   Normal zone: 4095 pages, LIFO batch:0
  [    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
  [    0.000000] pcpu-alloc: [0] 0 
  [    0.000000] Built 1 zonelists, mobility grouping off.  Total pages: 4059
  [    0.000000] Kernel command line: mem=16M loglevel=8
  [    0.000000] Parameter  is obsolete, ignored
  [    0.000000] Parameter  is obsolete, ignored
  [    0.000000] Dentry cache hash table entries: 2048 (order: 1, 8192 bytes)
  [    0.000000] Inode-cache hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.000000] Memory available: 16144k/16380k RAM
  [    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
  [    0.000000] NR_IRQS: 1024
  [    0.000000] lkl: irqs initialized
  [    0.000000] clocksource: lkl: mask: 0xffffffffffffffff max_cycles: 0x1cd42e4dffb, max_idle_ns: 881590591483 ns
  [    0.000100] lkl: time and timers initialized (irq1)
  [    0.001100] pid_max: default: 4096 minimum: 301
  [    0.009400] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.009900] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.327100] console [lkl_console0] enabled
  [    0.329600] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
  [    0.329700] xor: automatically using best checksumming function   8regs     
  [    0.341199] NET: Registered protocol family 16
  [    0.388999] clocksource: Switched to clocksource lkl
  [    0.414100] NET: Registered protocol family 2
  [    0.437700] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes)
  [    0.438199] TCP established hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.439000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes)
  [    0.439600] TCP: Hash tables configured (established 1024 bind 1024)
  [    0.443200] UDP hash table entries: 256 (order: 0, 4096 bytes)
  [    0.444000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
  [    0.472100] workingset: timestamp_bits=30 max_order=12 bucket_order=0
  [    0.863100] SGI XFS with ACLs, security attributes, no debug enabled
  [    0.923700] jitterentropy: Initialization failed with host not compliant with requirements: 2
  [    0.924599] io scheduler noop registered
  [    0.924900] io scheduler deadline registered
  [    0.933099] io scheduler cfq registered (default)
  [    0.933500] io scheduler kyber registered
  [    1.633500] NET: Registered protocol family 10
  [    1.658400] Segment Routing with IPv6
  [    1.660800] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
  [    1.674200] ------------[ cut here ]------------
  [    1.675500] WARNING: CPU: 0 PID: 0 at arch/lkl/kernel/setup.c:188   (null)
  [    1.675899] Call Trace:
  [    1.676200] 
  [    1.676999] ---[ end trace 941dc55fe0966cff ]---
  [    1.684299] Warning: unable to open an initial console.
  [    1.685200] This architecture does not have kernel memory protection.
  pthread_join((pthread_t)tid, NULL): No such process
  lkl_start_kernel(&amp;lkl_host_ops, "mem=16M loglevel=8") = 0 
</code></pre></div></div>

<h2 id="現在の問題点">現在の問題点</h2>

<p>以上より，JavaScript上で直接Linux kerenlが起動したことが確認できた．
しかし，現状ではdmesgが出力されるだけで全く実用には適さない．
これには次のような問題点が存在するためである．</p>

<ol>
  <li>kthreadの生成に失敗する</li>
  <li>rootfsのマウントに失敗する</li>
  <li>init</li>
</ol>

<p>また，Emscriptenでのpthreadのサポートがあまりよくない．
Little Kernel(LK)からsemaphore, mutex, threadの機能を抜き出し，
これらをgreen threadとして扱うLKLを作成した．</p>

<ul>
  <li>https://github.com/retrage/linux/tree/retrage/fiber</li>
</ul>

<p>これを用いたLKL.jsを作成することを予定している．</p>

<h2 id="まとめ">まとめ</h2>

<p>JavaScriptで書かれたLinux kernelをLKLからEmscriptenにより生成し，
これが起動し，dmesgが出力されることを確認した．
通常のマシンとJavaScriptではアーキテクチャが大きく異なるが，
いくつかの修正とworkaroundを加えることにより，
多少なりとも動作することがわかった．</p>

<h2 id="参考文献">参考文献</h2>

<ul>
  <li>https://github.com/lkl/linux</li>
  <li>https://github.com/kripken/emscripten</li>
  <li>https://llvm.org/</li>
  <li>https://clang.llvm.org/</li>
  <li>https://wiki.linuxfoundation.org/llvmlinux</li>
  <li>https://lwn.net/Articles/734071/</li>
  <li>http://llvm.org/docs/CommandGuide/llvm-link.html</li>
  <li>https://0xax.gitbooks.io/linux-insides/Concepts/linux-cpu-3.html</li>
  <li>https://github.com/littlekernel/lk</li>
</ul>

  </div><a class="u-url" href="/2018/07/21/lkl-js.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">retrage.github.io</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">retrage.github.io</li><li><a class="u-email" href="mailto:retrage01@gmail.com">retrage01@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/retrage"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">retrage</span></a></li><li><a href="https://www.twitter.com/retrage01"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">retrage01</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Blog posts by @retrage01</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
